<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC实时价格与专业K线图 (多指标版)</title>
    <style>
        /* 基本样式，保持与之前一致 */
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e222d;
            color: #eaecef;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .price-header {
            background-color: #2a2e39;
            border-radius: 4px;
            padding: 15px 20px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .price-info {
            display: flex;
            align-items: center;
        }
        .symbol {
            font-size: 18px;
            font-weight: bold;
            margin-right: 15px;
            color: #f0b90b;
        }
        .price {
            font-size: 24px;
            font-weight: bold;
            margin-right: 10px;
        }
        .price-up {
            color: #0ecb81;
        }
        .price-down {
            color: #f6465d;
        }
        .price-change {
            font-size: 14px;
            padding: 2px 6px;
            border-radius: 2px;
        }
        .price-up .price-change {
            background-color: rgba(14, 203, 129, 0.2);
            color: #0ecb81;
        }
         .price-down .price-change {
            background-color: rgba(246, 70, 93, 0.2);
            color: #f6465d;
        }
        .last-updated {
            font-size: 12px;
            color: #848e9c;
        }
        .chart-container {
            background-color: #2a2e39;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .chart-title {
            font-size: 16px;
            font-weight: bold;
        }
        .timeframe-tabs {
            display: flex;
            background-color: #1e222d;
            border-radius: 4px;
            padding: 2px;
        }
        .timeframe-tab {
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 2px;
            transition: background-color 0.2s ease;
        }
        .timeframe-tab:hover {
             background-color: #373c49;
        }
        .timeframe-tab.active {
            background-color: #2a2e39;
            color: #f0b90b;
        }
        .chart-wrapper {
            position: relative;
            /* 根据需要调整总高度，为新增的指标图留出空间 */
            height: 700px; /* 示例: K线图 + 成交量 + MFI + OBV 的总高度 */
            /* 确保 chart-wrapper 有明确的尺寸，Canvas 才能基于它计算 */
            width: 100%;
            display: flex; /* 使用 flex 布局垂直排列 Canvas */
            flex-direction: column;
        }
        #klineChart {
            width: 100%;
            /* K线图高度，减去其他图和间隔 */
            height: calc(100% - 100px - 100px - 100px - 30px); /* 示例: 总高 - 成交量 - MFI - OBV - 间隔 */
            display: block; /* 防止底部出现空白 */
        }
         #volumeChart {
            width: 100%;
            height: 100px; /* 成交量图高度 */
            display: block; /* 防止底部出现空白 */
             margin-top: 10px; /* 与上方图表的间隔 */
        }
        #mfiChart {
             width: 100%;
             height: 100px; /* MFI 图高度 */
             display: block;
             margin-top: 10px; /* 与上方图表的间隔 */
        }
         #obvChart {
             width: 100%;
             height: 100px; /* OBV 图高度 */
             display: block;
             margin-top: 10px; /* 与上方图表的间隔 */
         }

         /* 新增一个用于绘制十字线的透明 overlay Canvas */
        #crosshairOverlay {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%; /* overlay 覆盖整个 chart-wrapper */
             z-index: 5; /* 在所有图表 Canvas 之上，Loading 之下 */
             pointer-events: none; /* 允许鼠标事件穿透到下层 canvas */
        }

        /* 收盘倒计时样式 */
        #countdownTimer {
            position: absolute; /* 绝对定位在 chart-wrapper 内 */
            top: 0; /* 初始位置，将在 JS 中动态计算 */
            left: 0; /* 初始位置，将在 JS 中动态计算 */
            background-color: rgba(42, 46, 57, 0.9); /* 半透明背景 */
            color: #f0b90b; /* 文本颜色 */
            font-size: 12px;
            padding: 3px 6px;
            border-radius: 3px;
            z-index: 12; /* 在十字线信息框之下，图表之上 */
            display: none; /* 默认隐藏 */
            pointer-events: none; /* 允许鼠标事件穿透 */
            white-space: nowrap; /* 防止文本换行 */
        }


        .toolbar {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
             flex-wrap: wrap; /* 换行以适应小屏幕 */
        }
        .toolbar-group {
            display: flex;
            gap: 5px;
             margin-bottom: 5px; /* 添加底部间距，防止换行后粘连 */
        }
        .toolbar-btn {
            background-color: #373c49;
            border: none;
            color: #eaecef;
            padding: 5px 10px;
            border-radius: 2px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .toolbar-btn:hover {
            background-color: #4a4f5e;
        }
        .toolbar-btn.active {
            background-color: #f0b90b;
            color: #1e222d;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 34, 45, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            color: #f0b90b;
            font-size: 18px;
        }
        .crosshair-info {
            position: fixed; /* 使用 fixed 定位，避免受父元素滚动影响 */
            background-color: rgba(42, 46, 57, 0.9);
            border: 1px solid #373c49;
            padding: 5px 8px;
            font-size: 12px;
            pointer-events: none; /* 允许鼠标事件穿透 */
            z-index: 15; /* 确保在加载层之上 */
            display: none;
            border-radius: 4px;
            color: #eaecef;
            line-height: 1.5;
            white-space: nowrap; /* 防止信息框内容换行 */
        }
         .crosshair-info div span:first-child {
             color: #848e9c; /* 标签颜色 */
             display: inline-block;
             width: 60px; /* 标签固定宽度，稍微增加以容纳中文 */
             margin-right: 5px; /* 标签和值之间的间距 */
         }
    </style>
</head>
<body>
    <div class="container">
        <div class="price-header">
            <div class="price-info">
                <div class="symbol">BTC/USDT</div>
                <div class="price" id="btcPrice">--</div>
                <div class="price-change" id="priceChange">--%</div>
            </div>
            <div class="last-updated" id="lastUpdated">最后更新: --</div>
        </div>

        <div class="chart-container">
            <div class="chart-header">
                <div class="chart-title">K线图</div>
                <div class="timeframe-tabs">
                    <div class="timeframe-tab active" data-interval="1m">1分</div>
                    <div class="timeframe-tab" data-interval="5m">5分</div>
                    <div class="timeframe-tab" data-interval="15m">15分</div>
                    <div class="timeframe-tab" data-interval="1h">1小时</div>
                    <div class="timeframe-tab" data-interval="4h">4小时</div>
                    <div class="timeframe-tab" data-interval="1d">1日</div>
                </div>
            </div>

            <div class="chart-wrapper">
                <canvas id="klineChart"></canvas>
                 <canvas id="volumeChart"></canvas>
                 <canvas id="mfiChart"></canvas> <canvas id="obvChart"></canvas> <canvas id="crosshairOverlay"></canvas> <div class="loading-overlay" id="loadingOverlay">
                    <div>加载中...</div>
                </div>
                <div id="countdownTimer"></div>
            </div>

            <div class="toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn active" data-type="candle">蜡烛</button>
                    <button class="toolbar-btn" data-type="line">折线</button>
                    <button class="toolbar-btn" data-type="area">面积</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn active" data-indicator="ma">MA</button> <button class="toolbar-btn" data-indicator="boll">BOLL</button>
                    <button class="toolbar-btn active" data-indicator="ema20">EMA20</button> <button class="toolbar-btn active" data-indicator="ema83">EMA83</button> <button class="toolbar-btn active" data-indicator="ema120">EMA120</button> <button class="toolbar-btn" data-indicator="sar">SAR</button>
                </div>
                 <div class="toolbar-group">
                     <button class="toolbar-btn active" data-indicator="volume">成交量</button> <button class="toolbar-btn active" data-indicator="mfi">MFI</button> <button class="toolbar-btn active" data-indicator="obv">OBV</button> </div>
            </div>
        </div>
         <div class="crosshair-info" id="crosshairInfo"></div>
    </div>

    <script>
        // 使用 IIFE 包裹代码，创建独立作用域，避免全局变量污染
        (function() {
            // DOM元素引用
            const btcPriceElement = document.getElementById('btcPrice');
            const priceChangeElement = document.getElementById('priceChange');
            const lastUpdatedElement = document.getElementById('lastUpdated');
            const klineCanvas = document.getElementById('klineChart');
            const volumeCanvas = document.getElementById('volumeChart');
            const mfiCanvas = document.getElementById('mfiChart'); // MFI Canvas
            const obvCanvas = document.getElementById('obvChart'); // OBV Canvas
            const crosshairOverlay = document.getElementById('crosshairOverlay'); // 用于绘制十字线的透明 Canvas
            const timeframeTabs = document.querySelectorAll('.timeframe-tab');
            const chartTypeBtns = document.querySelectorAll('.toolbar-btn[data-type]');
            const indicatorBtns = document.querySelectorAll('.toolbar-btn[data-indicator]');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const crosshairInfo = document.getElementById('crosshairInfo');
            const countdownTimerElement = document.getElementById('countdownTimer'); // 倒计时元素

            // 图表上下文
            let klineCtx = null;
            let volumeCtx = null;
            let mfiCtx = null; // MFI Canvas 上下文
            let obvCtx = null; // OBV Canvas 上下文
            let crosshairCtx = null; // 十字线 Canvas 的上下文

            // 数据状态
            let klineData = []; // 当前时间周期下的 K 线数据
            let currentTimeframe = '1m'; // 当前选中的时间周期
            let currentChartType = 'candle'; // 当前选中的图表类型
            // 当前激活的技术指标，默认激活 MA, EMA20, EMA83, EMA120, 成交量, MFI, OBV
            let activeIndicators = ['ma', 'ema20', 'ema83', 'ema120', 'volume', 'mfi', 'obv'];
            let refreshInterval = null; // 自动刷新定时器 ID
            let lastPrice = 0; // 上一次获取的 BTC 价格，用于判断涨跌
            let priceDirection = 0; // 价格方向: 0: 无变化, 1: 上涨, -1: 下跌

            // K线数据缓存 { timeframe: data[] }，避免重复请求相同周期的数据
            const klineDataCache = new Map();

            // 图表配置和尺寸 (根据实际 canvas 尺寸计算)
            // 调整右侧和底部留白用于坐标轴标签
            const margin = { top: 20, right: 60, bottom: 30, left: 50 };
            let chartWidth = 0; // K 线图绘制区域宽度
            let klineChartHeight = 0; // K 线图绘制区域高度
            let volumeChartHeight = 0; // 成交量图绘制区域高度
            let mfiChartHeight = 0; // MFI 图绘制区域高度
            let obvChartHeight = 0; // OBV 图绘制区域高度
            let crosshairOverlayHeight = 0; // 十字线 overlay 高度
            let totalChartHeight = 0; // 所有图表 Canvas 的总高度 (CSS 高度)

            // 倒计时相关变量
            let countdownInterval = null; // 倒计时定时器 ID
            let currentKlineCloseTime = null; // 当前 K 线柱的收盘时间


            // --- 辅助函数和工具函数 (前置定义，确保调用时可用) ---

            // 格式化成交量数值，使其更易读 (例如 1.2B, 500M, 10K)
            function formatVolume(volume) {
                if (volume === undefined || volume === null || isNaN(volume)) return '--'; // 检查是否为有效数字
                if (volume >= 1000000000) {
                    return (volume / 1000000000).toFixed(1) + 'B'; // 十亿以上显示 B
                } else if (volume >= 1000000) {
                    return (volume / 1000000).toFixed(1) + 'M'; // 百万以上显示 M
                } else if (volume >= 1000) {
                    return (volume / 1000).toFixed(1) + 'K'; // 千以上显示 K
                }
                return volume.toFixed(0); // 小于千显示整数
            }

             // 绘制网格和坐标轴 (通用函数，用于 K 线图, 成交量图, MFI 图, OBV 图)
             // ctx: 绘制上下文, type: 图表类型 ('price', 'volume', 'mfi', 'obv'), yConverter: 数值转 Y 坐标函数, xConverter: 时间转 X 坐标函数
             // maxY, minY: 数值范围, startTime, endTime: 时间范围, width, height: 绘制区域尺寸 (逻辑尺寸)
             // margin: 边距, interval: 时间间隔, isSubChart: 是否是子图 (成交量、MFI、OBV), canvasTop: 当前 Canvas 相对于 chart-wrapper 顶部的偏移
             function drawGridAndAxes(ctx, type, yConverter, xConverter, maxY, minY, startTime, endTime, width, height, margin, interval, isSubChart = false) {
                 ctx.strokeStyle = '#373c49'; // 网格线颜色
                 ctx.lineWidth = 1; // 网格线宽度

                 // 绘制图表区域的边框
                 ctx.strokeRect(margin.left, margin.top, width, height);

                 // 绘制水平网格线和价格/成交量标签
                 const ySteps = isSubChart ? 2 : 5; // 子图（成交量、MFI、OBV）简单分段，K 线图分段更多
                 for (let i = 0; i <= ySteps; i++) {
                     // 计算当前网格线对应的数值 (价格、成交量、MFI 或 OBV)
                     const value = minY + ((maxY - minY) * i / ySteps);
                     // 将数值转换为 Canvas 上的 Y 坐标
                     const y = yConverter(value);

                     // 绘制网格线 (避开边框线)
                     // 子图绘制中间线，K 线图不绘制最顶部和最底部的水平网格线
                     if ((i > 0 && i < ySteps) || isSubChart) {
                         ctx.beginPath();
                         ctx.setLineDash([2, 2]); // 设置虚线样式
                         ctx.moveTo(margin.left, y); // 从左边框开始
                         ctx.lineTo(margin.left + width, y); // 画到右边框
                         ctx.stroke(); // 绘制线条
                         ctx.setLineDash([]); // 恢复实线样式
                     }


                     // 绘制价格/成交量标签 (只在左侧绘制)
                     ctx.fillStyle = '#848e9c'; // 标签文本颜色
                     ctx.font = '10px Arial'; // 标签字体
                     ctx.textAlign = 'right'; // 文本右对齐
                     ctx.textBaseline = 'middle'; // 文本垂直居中对齐到 Y 坐标
                     // 格式化标签文本
                     let labelText;
                     if (type === 'volume' || type === 'obv') {
                         labelText = formatVolume(value); // 成交量和 OBV 使用成交量格式化
                     } else if (type === 'mfi') {
                         labelText = value.toFixed(0); // MFI 显示整数
                     } else { // price
                         labelText = value.toFixed(maxY > 1000 ? 0 : 2); // 根据价格大小调整小数位数
                     }

                      if (value === 0 && (type === 'volume' || type === 'obv')) labelText = '0'; // 确保成交量/OBV 轴底部的0显示


                     // 绘制标签文本，位置在左边框左侧一点
                     ctx.fillText(labelText, margin.left - 5, y);
                 }

                 // 绘制垂直网格线和时间标签 (只在最底部的图表绘制)
                 // 判断是否是最底部的图表 (OBV 或 MFI/Volume 如果 OBV 不激活)
                 const isBottomChart = (type === 'obv' && activeIndicators.includes('obv')) ||
                                       (type === 'mfi' && !activeIndicators.includes('obv') && activeIndicators.includes('mfi')) ||
                                       (type === 'volume' && !activeIndicators.includes('obv') && !activeIndicators.includes('mfi') && activeIndicators.includes('volume')) ||
                                       (!activeIndicators.includes('obv') && !activeIndicators.includes('mfi') && !activeIndicators.includes('volume') && type === 'price');


                 if (isBottomChart) {
                     const timeRange = endTime - startTime;
                     const timeSteps = Math.min(10, klineData.length); // 最多显示 10 个时间标签
                      // 根据时间间隔和数据点数量调整显示的标签数量，避免拥挤
                     let step = 1;
                      if (klineData.length > 100 && (interval === '1m' || interval === '5m')) {
                          step = 10; // 数据点多时，跳过一些标签
                      } else if (klineData.length > 200 && (interval === '15m' || interval === '1h')) {
                           step = 20;
                      } else if (klineData.length > 100 && interval === '4h') { // 4小时图数据点较多时
                          step = 10;
                      }

                      // 确定需要绘制标签的数据点索引
                      const indicesToDraw = [];
                      for (let i = 0; i < klineData.length; i+= step) {
                          indicesToDraw.push(i);
                      }
                      // 如果最后一个数据点没有被包含，且数据点数量大于 1，则添加，确保图表右侧有时间标签
                      if (klineData.length > 1 && !indicesToDraw.includes(klineData.length - 1)) {
                          indicesToDraw.push(klineData.length - 1);
                      }


                     if (timeSteps > 0) {
                          indicesToDraw.forEach(i => {
                              const time = klineData[i].time;
                              // 将时间转换为 Canvas 上的 X 坐标
                              const x = xConverter(time);

                              // 绘制网格线 (避开边框线)
                               // 不绘制最左侧和最右侧的垂直网格线
                               if (i > 0 && i < klineData.length - 1) {
                                  ctx.beginPath();
                                  ctx.setLineDash([2, 2]); // 设置虚线样式
                                  ctx.moveTo(x, margin.top); // 从上边框开始
                                  ctx.lineTo(x, margin.top + height); // 画到下边框
                                  ctx.stroke(); // 绘制线条
                                  ctx.setLineDash([]); // 恢复实线样式
                              }


                              // 绘制时间标签 (只在底部绘制)
                              ctx.fillStyle = '#848e9c'; // 标签文本颜色
                              ctx.font = '10px Arial'; // 标签字体
                              ctx.textAlign = 'center'; // 文本居中对齐
                              ctx.textBaseline = 'top'; // 文本顶部对齐到 Y 坐标
                              let timeStr;

                              // 根据时间间隔格式化时间字符串
                              if (interval === '1d') {
                                  timeStr = time.toLocaleDateString([], { month: 'short', day: 'numeric' }); // 日期格式
                              } else if (interval === '4h') {
                                  timeStr = `${time.getMonth() + 1}/${time.getDate()} ${time.getHours()}:00`; // 月/日 时:00 格式
                              }
                              else {
                                  timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); // 时:分 格式
                              }

                              // 确保时间标签不会超出左右边界
                              ctx.font = '10px Arial'; // 再次设置字体，确保measureText准确
                              const textWidth = ctx.measureText(timeStr).width; // 测量文本宽度
                              // 计算标签绘制的 X 坐标，确保居中且不越界
                              const labelX = Math.max(margin.left, Math.min(margin.left + width - textWidth/2, x - textWidth/2));

                              // 绘制标签文本，位置在下边框下方一点
                              ctx.fillText(timeStr, labelX, margin.top + height + 5); // 修正：使用 labelX
                          });
                     }
                 }
             }

            // 绘制蜡烛图
            function drawCandles(priceToY, timeToX, data, ctx, chartWidth) {
                 // 根据数据点数量动态计算蜡烛宽度和间隔
                 const barSpacing = chartWidth / data.length; // 每个数据点占用的水平空间
                 const candleWidth = Math.max(0.5, barSpacing * 0.8); // 蜡烛实体宽度，留白 20%，确保最小宽度
                 const offset = barSpacing / 2; // 蜡烛中心相对于数据点起始位置的偏移量


                data.forEach((item, index) => {
                    // 计算蜡烛中心在 Canvas 上的 X 坐标
                    const x = margin.left + (index * barSpacing) + offset;
                    // 将开盘价、收盘价、最高价、最低价转换为 Canvas 上的 Y 坐标
                    const openY = priceToY(item.open);
                    const closeY = priceToY(item.close);
                    const highY = priceToY(item.high);
                    const lowY = priceToY(item.low);

                    // 确定蜡烛的涨跌颜色
                    const isUp = item.close >= item.open;
                    ctx.fillStyle = isUp ? '#0ecb81' : '#f6465d'; // 实体填充颜色
                    ctx.strokeStyle = isUp ? '#0ecb81' : '#f6465d'; // 影线和边框颜色
                     ctx.lineWidth = 1; // 边框和影线宽度

                    // 绘制影线 (从最高点到最低点)
                    ctx.beginPath();
                    ctx.moveTo(x, highY);
                    ctx.lineTo(x, lowY);
                    ctx.stroke();

                    // 绘制蜡烛实体
                    const candleHeight = Math.abs(openY - closeY); // 实体高度
                    const candleY = Math.min(openY, closeY); // 实体顶部的 Y 坐标

                    // 如果开盘价等于收盘价或非常接近，绘制一条横线表示“一字线”
                     if (candleHeight < 1 / (window.devicePixelRatio || 1)) { // 小于1像素高度的视为一条线，考虑 DPR
                         ctx.beginPath();
                         ctx.moveTo(x - candleWidth / 2, openY);
                         ctx.lineTo(x + candleWidth / 2, openY);
                         ctx.stroke();
                     } else {
                        // 绘制实体矩形
                        ctx.fillRect(x - candleWidth / 2, candleY, candleWidth, candleHeight);
                        // 绘制蜡烛边框 (可选，与实体颜色相同)
                        // ctx.strokeRect(x - candleWidth / 2, candleY, candleWidth, candleHeight);
                     }
                });
            }

            // 绘制折线图 (使用收盘价连接形成的折线)
            function drawLineChart(priceToY, timeToX, data, ctx, chartWidth) {
                ctx.strokeStyle = '#f0b90b'; // 折线颜色
                ctx.lineWidth = 2; // 折线宽度
                ctx.beginPath(); // 开始绘制路径

                 // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length; // 每个数据点占用的水平空间
                 const offset = barSpacing / 2; // 点中心相对于数据点起始位置的偏移量


                data.forEach((item, index) => {
                    // 计算数据点中心在 Canvas 上的 X 坐标
                    const x = margin.left + (index * barSpacing) + offset;
                    // 将收盘价转换为 Canvas 上的 Y 坐标
                    const y = priceToY(item.close);

                    // 如果是第一个点，移动到该点；否则，连接到该点
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke(); // 绘制路径
            }

            // 绘制面积图 (收盘价折线与图表底部形成的区域)
            function drawAreaChart(priceToY, timeToX, data, ctx, minPrice, priceRange, chartWidth, margin) {
                ctx.fillStyle = 'rgba(240, 185, 11, 0.2)'; // 填充颜色 (半透明黄色)
                ctx.strokeStyle = '#f0b90b'; // 边框颜色 (黄色)
                ctx.lineWidth = 2; // 边框宽度
                ctx.beginPath(); // 开始绘制路径

                // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length; // 每个数据点占用的水平空间
                 const offset = barSpacing / 2; // 点中心相对于数据点起始位置的偏移量


                // 绘制上边线 (收盘价折线)
                data.forEach((item, index) => {
                     // 计算数据点中心在 Canvas 上的 X 坐标
                     const x = margin.left + (index * barSpacing) + offset;
                    // 将收盘价转换为 Canvas 上的 Y 坐标
                    const y = priceToY(item.close);

                    // 如果是第一个点，移动到该点；否则，连接到该点
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                // 绘制下边线形成闭合区域 (连接到图表底部中心)
                 // 面积图底部延伸到图表底部 (考虑 margin)
                 const baseY = margin.top + klineChartHeight;

                 // 计算最后一个数据点和第一个数据点的 X 坐标
                 const lastX = margin.left + (data.length - 1) * barSpacing + offset;
                 const firstX = margin.left + (0 * barSpacing) + offset;

                // 从最后一个数据点连接到图表右下角
                ctx.lineTo(lastX, baseY);
                // 从图表右下角连接到图表左下角
                ctx.lineTo(firstX, baseY);
                // 从图表左下角连接回第一个数据点 (闭合路径)
                ctx.closePath();

                ctx.fill(); // 填充区域
                ctx.stroke(); // 绘制边框
            }

            // 绘制移动平均线 (MA)
            function drawMA(priceToY, timeToX, data, ctx, margin, chartWidth) {
                const maColors = ['#9b59b6', '#3498db', '#e74c3c']; // MA5, MA10, MA20的颜色
                const periods = [5, 10, 20]; // MA 计算周期

                 // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length; // 每个数据点占用的水平空间
                 const offset = barSpacing / 2; // 点中心相对于数据点起始位置的偏移量


                periods.forEach((period, idx) => {
                    // 只有当指标被激活且数据长度足够计算当前周期的 MA 时才绘制
                    if (!activeIndicators.includes('ma') || data.length < period) return;

                    ctx.strokeStyle = maColors[idx % maColors.length]; // 设置线条颜色，循环使用
                    ctx.lineWidth = 1; // 线条宽度
                    ctx.beginPath(); // 开始绘制路径

                    // 从第一个可以计算 MA 的数据点开始绘制
                    for (let i = period - 1; i < data.length; i++) {
                        const x = margin.left + (i * barSpacing) + offset; // 点的 X 坐标
                        const y = priceToY(data[i][`ma${period}`]); // 使用计算好的 MA 值

                        if (i === period - 1) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke(); // 绘制路径

                    // 添加图例/标签 (只显示最后一个点的数值)
                     const lastItem = data[data.length - 1];
                     // 确保最后一个数据点存在计算出的 MA 值
                     if (lastItem && lastItem[`ma${period}`] !== undefined && !isNaN(lastItem[`ma${period}`])) {
                         // 构建标签文本
                         const labelText = `MA${period}: ${lastItem[`ma${period}`].toFixed(2)}`;
                         // 计算标签绘制的 X, Y 坐标，使其位于图表右上角区域
                         // 根据标签数量调整起始位置和间隔，避免重叠
                         const labelX = margin.left + chartWidth - 180 + idx * 60; // 右侧区域，调整起始位置和间隔
                         const labelY = margin.top + 15 + idx * 15; // 顶部区域，调整起始位置和间隔

                         ctx.fillStyle = maColors[idx % maColors.length]; // 使用与 MA 线相同的颜色
                         ctx.font = '10px Arial'; // 字体
                         ctx.textAlign = 'left'; // 文本左对齐
                          ctx.textBaseline = 'top'; // 文本顶部对齐到 Y 坐标
                         ctx.fillText(labelText, labelX, labelY); // 绘制文本
                     }
                });
            }

             // 绘制 BOLL (布林带)
             function drawBOLL(priceToY, timeToX, data, ctx, margin, chartWidth) {
                 // 只有当 BOLL 指标被激活且数据长度足够时才绘制
                 if (!activeIndicators.includes('boll') || data.length < 20) return; // BOLL 默认周期 20

                 const bollColors = {
                     mid: '#f0b90b', // 中轨颜色
                     upper: '#e74c3c', // 上轨颜色
                     lower: '#3498db' // 下轨颜色
                 };

                 // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length;
                 const offset = barSpacing / 2;

                 // 绘制中轨
                 ctx.strokeStyle = bollColors.mid;
                 ctx.lineWidth = 1;
                 ctx.beginPath();
                 for (let i = 19; i < data.length; i++) { // 从第 20 个点开始有 BOLL 值
                     const x = margin.left + (i * barSpacing) + offset;
                     const y = priceToY(data[i].bollMid);
                     if (i === 19) {
                         ctx.moveTo(x, y);
                     } else {
                         ctx.lineTo(x, y);
                     }
                 }
                 ctx.stroke();

                 // 绘制上轨
                 ctx.strokeStyle = bollColors.upper;
                 ctx.lineWidth = 1;
                 ctx.beginPath();
                 for (let i = 19; i < data.length; i++) {
                     const x = margin.left + (i * barSpacing) + offset;
                     const y = priceToY(data[i].bollUpper);
                     if (i === 19) {
                         ctx.moveTo(x, y);
                     } else {
                         ctx.lineTo(x, y);
                     }
                 }
                 ctx.stroke();

                 // 绘制下轨
                 ctx.strokeStyle = bollColors.lower;
                 ctx.lineWidth = 1;
                 ctx.beginPath();
                 for (let i = 19; i < data.length; i++) {
                     const x = margin.left + (i * barSpacing) + offset;
                     const y = priceToY(data[i].bollLower);
                     if (i === 19) {
                         ctx.moveTo(x, y);
                     } else {
                         ctx.lineTo(x, y);
                     }
                 }
                 ctx.stroke();

                 // 添加图例/标签 (只显示最后一个点的数值)
                 const lastItem = data[data.length - 1];
                 if (lastItem && lastItem.bollMid !== undefined) {
                      const labelX = margin.left + chartWidth - 180; // 右侧区域
                      let labelYOffset = 15; // 初始 Y 偏移
                      // 查找 MA 指标的数量，以便调整 BOLL 图例的 Y 位置
                      const maPeriods = [5, 10, 20];
                      const activeMaCount = maPeriods.filter(p => activeIndicators.includes('ma')).length;
                      labelYOffset += activeMaCount * 15; // 每个激活的 MA 增加 15px Y 偏移


                     ctx.fillStyle = bollColors.mid;
                     ctx.font = '10px Arial';
                     ctx.textAlign = 'left';
                     ctx.textBaseline = 'top';
                     ctx.fillText(`BOLL(20):`, labelX, margin.top + labelYOffset);

                     ctx.fillStyle = bollColors.upper;
                     ctx.fillText(`UP:${lastItem.bollUpper.toFixed(2)}`, labelX + 60, margin.top + labelYOffset);

                     ctx.fillStyle = bollColors.lower;
                     ctx.fillText(`DN:${lastItem.bollLower.toFixed(2)}`, labelX + 120, margin.top + labelYOffset);

                 }
             }

             // 绘制 EMA (指数移动平均线)
             function drawEMA(priceToY, timeToX, data, ctx, margin, chartWidth, activeIndicators) {
                 const emaColors = {
                     ema20: '#9b59b6', // EMA20 颜色
                     ema83: '#3498db', // EMA83 颜色
                     ema120: '#e74c3c' // EMA120 颜色
                 };
                 const emaPeriods = [20, 83, 120];

                 // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length;
                 const offset = barSpacing / 2;


                 emaPeriods.forEach(period => {
                     const indicatorKey = `ema${period}`;
                     // 只有当对应的 EMA 指标被激活且数据长度足够时才绘制
                     if (!activeIndicators.includes(indicatorKey) || data.length < period) return;

                     ctx.strokeStyle = emaColors[indicatorKey]; // 设置线条颜色
                     ctx.lineWidth = 1; // 线条宽度
                     ctx.beginPath(); // 开始绘制路径

                     // 从第一个可以计算 EMA 的数据点开始绘制
                     for (let i = period - 1; i < data.length; i++) {
                         const x = margin.left + (i * barSpacing) + offset; // 点的 X 坐标
                         const y = priceToY(data[i][indicatorKey]); // 使用计算好的 EMA 值

                         if (i === period - 1) {
                             ctx.moveTo(x, y);
                         } else {
                             ctx.lineTo(x, y);
                         }
                     }
                     ctx.stroke(); // 绘制路径

                     // 添加图例/标签 (只显示最后一个点的数值)
                     const lastItem = data[data.length - 1];
                     if (lastItem && lastItem[indicatorKey] !== undefined && !isNaN(lastItem[indicatorKey])) {
                         const labelText = `${indicatorKey.toUpperCase()}: ${lastItem[indicatorKey].toFixed(2)}`;
                         let labelX = margin.left + chartWidth - 180; // 右侧区域，初始 X 位置
                         let labelYOffset = 15; // 初始 Y 偏移

                          // 查找 MA 指标的数量，以便调整 EMA 图例的 Y 位置
                          const maPeriods = [5, 10, 20];
                          const activeMaCount = maPeriods.filter(p => activeIndicators.includes('ma')).length;
                          labelYOffset += activeMaCount * 15; // 每个激活的 MA 增加 15px Y 偏移

                          // 查找 BOLL 是否激活，以便调整 EMA 图例的 Y 位置
                          if(activeIndicators.includes('boll')) {
                              labelYOffset += 15; // 如果 BOLL 激活，再增加 15px Y 偏移
                          }

                          // 根据 EMA 周期调整 X 位置，避免重叠
                          if (period === 83) labelX += 60;
                          if (period === 120) labelX += 120;


                         ctx.fillStyle = emaColors[indicatorKey]; // 使用相同的颜色
                         ctx.font = '10px Arial';
                         ctx.textAlign = 'left';
                         ctx.textBaseline = 'top';
                         ctx.fillText(labelText, labelX, margin.top + labelYOffset);
                     }
                 });
             }


             // 绘制 SAR (抛物线转向指标)
             function drawSAR(priceToY, timeToX, data, ctx, margin, chartWidth) {
                 // 只有当 SAR 指标被激活且数据长度足够时才绘制
                 if (!activeIndicators.includes('sar') || data.length < 2) return; // SAR 需要至少两个点

                 const sarColor = '#ffffff'; // SAR 点颜色
                 const pointSize = 3; // SAR 点的大小

                 // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length;
                 const offset = barSpacing / 2;


                 ctx.fillStyle = sarColor; // 设置填充颜色

                 for (let i = 1; i < data.length; i++) { // 从第二个点开始绘制 SAR
                     const item = data[i];
                     // 确保 SAR 值存在且是有效数字
                     if (item.sar !== undefined && !isNaN(item.sar)) {
                         const x = margin.left + (i * barSpacing) + offset; // 点的 X 坐标
                         const y = priceToY(item.sar); // 将 SAR 值转换为 Y 坐标

                         // 绘制 SAR 点 (圆形)
                         ctx.beginPath();
                         ctx.arc(x, y, pointSize, 0, Math.PI * 2); // 绘制圆形
                         ctx.fill(); // 填充圆形
                     }
                 }

                 // 添加图例/标签 (只显示最后一个点的数值)
                 const lastItem = data[data.length - 1];
                 if (lastItem && lastItem.sar !== undefined && !isNaN(lastItem.sar)) {
                     const labelText = `SAR: ${lastItem.sar.toFixed(2)}`;
                     let labelX = margin.left + chartWidth - 180; // 右侧区域，初始 X 位置
                     let labelYOffset = 15; // 初始 Y 偏移

                      // 查找 MA 指标的数量
                      const maPeriods = [5, 10, 20];
                      const activeMaCount = maPeriods.filter(p => activeIndicators.includes('ma')).length;
                      labelYOffset += activeMaCount * 15; // 每个激活的 MA 增加 15px Y 偏移

                      // 查找 BOLL 是否激活
                      if(activeIndicators.includes('boll')) {
                          labelYOffset += 15; // 如果 BOLL 激活，再增加 15px Y 偏移
                      }

                       // 查找 EMA 指标的数量
                       const emaPeriods = [20, 83, 120];
                       const activeEmaCount = emaPeriods.filter(p => activeIndicators.includes(`ema${p}`)).length;
                       labelYOffset += activeEmaCount * 15; // 每个激活的 EMA 增加 15px Y 偏移


                     ctx.fillStyle = sarColor; // 使用相同的颜色
                     ctx.font = '10px Arial';
                     ctx.textAlign = 'left';
                     ctx.textBaseline = 'top';
                     ctx.fillText(labelText, labelX, margin.top + labelYOffset);
                 }
             }

            // 计算技术指标
            function calculateIndicators() {
                // 在此处添加各种技术指标计算逻辑，计算结果直接添加到 klineData 的每个 item 中

                // 移除旧的指标数据，避免重复计算或残留
                klineData.forEach(item => {
                     delete item.ma5; delete item.ma10; delete item.ma20;
                     delete item.ema20; delete item.ema83; delete item.ema120;
                     delete item.bollMid; delete item.bollUpper; delete item.bollLower;
                     delete item.sar; delete item.ep; delete item.af; delete item.isRising; // 清除 SAR 相关辅助属性
                     delete item.tp; delete item.moneyFlow; delete item.positiveMoneyFlow; delete item.negativeMoneyFlow; delete item.mfi; // 清除 MFI 相关辅助属性
                     delete item.obv;
                });


                // 计算 MA (简单移动平均线)
                if (activeIndicators.includes('ma') && klineData.length > 0) {
                    const periods = [5, 10, 20];
                    periods.forEach(period => {
                         if (klineData.length >= period) {
                             for (let i = period - 1; i < klineData.length; i++) {
                                 let sum = 0;
                                 for (let j = 0; j < period; j++) {
                                     sum += klineData[i - j].close;
                                 }
                                 klineData[i][`ma${period}`] = sum / period;
                             }
                         }
                    });
                }

                // 计算 EMA (指数移动平均线)
                const emaPeriods = [20, 83, 120];
                emaPeriods.forEach(period => {
                     if (activeIndicators.includes(`ema${period}`) && klineData.length > 0) {
                         if (klineData.length >= period) {
                             const multiplier = 2 / (period + 1);
                             // 计算第一个 EMA 值 (通常使用 SMA 作为第一个 EMA)
                             let firstEMA = 0;
                             for (let i = 0; i < period; i++) {
                                 firstEMA += klineData[i].close;
                             }
                             klineData[period - 1][`ema${period}`] = firstEMA / period;

                             // 计算后续的 EMA 值
                             for (let i = period; i < klineData.length; i++) {
                                 klineData[i][`ema${period}`] = (klineData[i].close - klineData[i - 1][`ema${period}`]) * multiplier + klineData[i - 1][`ema${period}`];
                             }
                         }
                     }
                });


                // 计算 BOLL (布林带) - 周期 20
                if (activeIndicators.includes('boll') && klineData.length > 0) {
                    const period = 20;
                    const multiplier = 2; // 标准差乘数

                    if (klineData.length >= period) {
                        for (let i = period - 1; i < klineData.length; i++) {
                            // 计算 SMA (中轨)
                            let sum = 0;
                            for (let j = 0; j < period; j++) {
                                sum += klineData[i - j].close;
                            }
                            const sma = sum / period;
                            klineData[i].bollMid = sma;

                            // 计算标准差
                            let sumSqDiff = 0;
                            for (let j = 0; j < period; j++) {
                                sumSqDiff += Math.pow(klineData[i - j].close - sma, 2);
                            }
                            const stdDev = Math.sqrt(sumSqDiff / period);

                            // 计算上轨和下轨
                            klineData[i].bollUpper = sma + (stdDev * multiplier);
                            klineData[i].bollLower = sma - (stdDev * multiplier);
                        }
                    }
                }

                // 计算 SAR (抛物线转向指标)
                if (activeIndicators.includes('sar') && klineData.length > 0) {
                    const initialAF = 0.02; // 初始加速因子
                    const incrementAF = 0.02; // 加速因子增量
                    const maxAF = 0.2; // 最大加速因子

                    // 初始化第一个 SAR 值
                    if (klineData.length > 0) {
                         // 第一个 SAR 通常是第一个最高价或最低价
                         klineData[0].sar = klineData[0].low; // 示例：假设第一个点是上涨趋势开始
                         klineData[0].ep = klineData[0].high; // 极点
                         klineData[0].af = initialAF; // 加速因子
                         klineData[0].isRising = true; // 示例：假设第一个点是上涨趋势
                    }

                    for (let i = 1; i < klineData.length; i++) {
                        let prevItem = klineData[i - 1];
                        let currentItem = klineData[i];

                        // SAR 计算逻辑 (简化示例，实际算法更复杂)
                        // 需要判断当前趋势方向 (上涨或下跌)
                        // 根据趋势方向更新 EP (极点) 和 AF (加速因子)
                        // 计算新的 SAR 值

                        // 这是一个非常简化的 SAR 示例，仅为占位符
                        // 实际 SAR 计算需要更精细的逻辑来判断趋势反转
                        if (prevItem.isRising) { // 如果前一个点是上涨趋势
                            currentItem.sar = prevItem.sar + prevItem.af * (prevItem.ep - prevItem.sar);
                            currentItem.ep = Math.max(prevItem.ep, currentItem.high); // 更新极点 (上涨趋势取最高价)
                            // 如果新的极点高于前一个极点，增加加速因子
                            currentItem.af = currentItem.ep > prevItem.ep ? Math.min(maxAF, prevItem.af + incrementAF) : prevItem.af;

                            // 判断是否发生反转
                            if (currentItem.low < currentItem.sar) {
                                currentItem.isRising = false; // 趋势反转为下跌
                                currentItem.sar = prevItem.ep; // 反转后的 SAR 是前一个极点
                                currentItem.ep = currentItem.low; // 反转后的极点是当前最低价
                                currentItem.af = initialAF; // 加速因子重置
                            } else {
                                currentItem.isRising = true; // 保持上涨趋势
                            }

                        } else { // 如果前一个点是下跌趋势
                            currentItem.sar = prevItem.sar - prevItem.af * (prevItem.sar - prevItem.ep);
                            currentItem.ep = Math.min(prevItem.ep, currentItem.low); // 更新极点 (下跌趋势取最低价)
                             // 如果新的极点低于前一个极点，增加加速因子
                            currentItem.af = currentItem.ep < prevItem.ep ? Math.min(maxAF, prevItem.af + incrementAF) : prevItem.af;

                            // 判断是否发生反转
                            if (currentItem.high > currentItem.sar) {
                                currentItem.isRising = true; // 趋势反转为上涨
                                currentItem.sar = prevItem.ep; // 反转后的 SAR 是前一个极点
                                currentItem.ep = currentItem.high; // 反转后的极点是当前最高价
                                currentItem.af = initialAF; // 加速因子重置
                            } else {
                                currentItem.isRising = false; // 保持下跌趋势
                            }
                        }

                         // 确保 SAR 值不进入当前 K 线范围内
                         if (currentItem.isRising && currentItem.sar > currentItem.low) {
                             currentItem.sar = currentItem.low;
                         } else if (!currentItem.isRising && currentItem.sar < currentItem.high) {
                             currentItem.sar = currentItem.high;
                         }

                        klineData[i].sar = currentItem.sar;
                        klineData[i].ep = currentItem.ep;
                        klineData[i].af = currentItem.af;
                        klineData[i].isRising = currentItem.isRising;
                    }
                }


                // 计算 MFI (资金流量指标) - 周期 14
                if (activeIndicators.includes('mfi') && klineData.length > 0) {
                     const period = 14;

                     // 步骤 1: 计算典型价格 (Typical Price)
                     klineData.forEach(item => {
                         item.tp = (item.high + item.low + item.close) / 3;
                     });

                     // 步骤 2: 计算资金流量 (Money Flow)
                     klineData.forEach((item, index) => {
                         if (index > 0) {
                             item.moneyFlow = item.tp * item.volume;
                             // 判断正资金流量或负资金流量
                             if (item.tp > klineData[index - 1].tp) {
                                 item.positiveMoneyFlow = item.moneyFlow;
                                 item.negativeMoneyFlow = 0;
                             } else if (item.tp < klineData[index - 1].tp) {
                                 item.positiveMoneyFlow = 0;
                                 item.negativeMoneyFlow = item.moneyFlow;
                             } else {
                                 item.positiveMoneyFlow = 0;
                                 item.negativeMoneyFlow = 0;
                             }
                         } else {
                             item.moneyFlow = item.tp * item.volume; // 第一个点的资金流量
                             item.positiveMoneyFlow = 0; // 第一个点没有前一个点比较，正负资金流量为0
                             item.negativeMoneyFlow = 0;
                         }
                     });

                     // 步骤 3: 计算资金流量比率 (Money Flow Ratio) 和 MFI
                     if (klineData.length >= period) {
                         for (let i = period - 1; i < klineData.length; i++) {
                             let sumPositiveMoneyFlow = 0;
                             let sumNegativeMoneyFlow = 0;

                             for (let j = 0; j < period; j++) {
                                 sumPositiveMoneyFlow += klineData[i - j].positiveMoneyFlow || 0; // 确保取到有效值
                                 sumNegativeMoneyFlow += klineData[i - j].negativeMoneyFlow || 0;
                             }

                             // 避免除以零
                             const moneyFlowRatio = sumNegativeMoneyFlow !== 0 ? sumPositiveMoneyFlow / sumNegativeMoneyFlow : (sumPositiveMoneyFlow > 0 ? Infinity : 0);

                             // 计算 MFI (公式: 100 - (100 / (1 + Money Flow Ratio)))
                             // 避免 1 + moneyFlowRatio 为零或负数
                             const denominator = 1 + moneyFlowRatio;
                             klineData[i].mfi = denominator !== 0 ? (100 - (100 / denominator)) : (moneyFlowRatio === Infinity ? 100 : 0);

                              // 确保 MFI 在 0-100 范围内
                             klineData[i].mfi = Math.max(0, Math.min(100, klineData[i].mfi));
                         }
                     }
                }

                // 计算 OBV (能量潮)
                if (activeIndicators.includes('obv') && klineData.length > 0) {
                     // 初始化第一个 OBV 值
                     if (klineData.length > 0) {
                         klineData[0].obv = klineData[0].volume;
                     }

                     // 计算后续 OBV 值
                     for (let i = 1; i < klineData.length; i++) {
                         const prevObv = klineData[i - 1].obv || 0; // 如果前一个 OBV 不存在，视为 0
                         const currentItem = klineData[i];
                         const prevItem = klineData[i - 1];

                         if (currentItem.close > prevItem.close) {
                             currentItem.obv = prevObv + currentItem.volume; // 收盘价上涨，OBV 增加当前成交量
                         } else if (currentItem.close < prevItem.close) {
                             currentItem.obv = prevObv - currentItem.volume; // 收盘价下跌，OBV 减少当前成交量
                         } else {
                             currentItem.obv = prevObv; // 收盘价不变，OBV 不变
                         }
                         klineData[i].obv = currentItem.obv;
                     }
                }
            }


            // --- 主要图表绘制函数 (调用辅助绘制函数) ---

            // 绘制 K 线图主体和叠加指标 (MA, BOLL, EMA, SAR)
            function drawKlineChart() {
                if (klineData.length === 0 || !klineCtx) return;

                // 计算价格范围 (用于确定 Y 轴的缩放比例)
                let maxPrice = -Infinity;
                let minPrice = Infinity;

                klineData.forEach(item => {
                    // 考虑 K 线的最高价和最低价
                    maxPrice = Math.max(maxPrice, item.high);
                    minPrice = Math.min(minPrice, item.low);
                     // 考虑激活的 MA 指标的最大最小值
                     if (activeIndicators.includes('ma')) {
                         const periods = [5, 10, 20];
                         periods.forEach(period => {
                             if (item[`ma${period}`] !== undefined && !isNaN(item[`ma${period}`])) {
                                 maxPrice = Math.max(maxPrice, item[`ma${period}`]);
                                 minPrice = Math.min(minPrice, item[`ma${period}`]);
                             }
                         });
                     }
                     // 考虑激活的 EMA 指标的最大最小值
                     const emaPeriods = [20, 83, 120];
                     emaPeriods.forEach(period => {
                          if (activeIndicators.includes(`ema${period}`) && item[`ema${period}`] !== undefined && !isNaN(item[`ema${period}`])) {
                              maxPrice = Math.max(maxPrice, item[`ema${period}`]);
                              minPrice = Math.min(minPrice, item[`ema${period}`]);
                          }
                     });
                     // 考虑激活的 BOLL 指标的最大最小值
                     if (activeIndicators.includes('boll') && item.bollUpper !== undefined && !isNaN(item.bollUpper)) {
                         maxPrice = Math.max(maxPrice, item.bollUpper);
                         minPrice = Math.min(minPrice, item.bollLower);
                     }
                     // 考虑激活的 SAR 指标的最大最小值
                     if (activeIndicators.includes('sar') && item.sar !== undefined && !isNaN(item.sar)) {
                         maxPrice = Math.max(maxPrice, item.sar);
                         minPrice = Math.min(minPrice, item.sar);
                     }
                });

                // 添加一些 padding，防止最高最低价紧贴图表边界
                const priceRange = maxPrice - minPrice;
                const pricePadding = priceRange * 0.1; // 10% padding
                maxPrice += pricePadding;
                minPrice -= pricePadding;

                // 如果价格范围为零（所有价格相同），给一个默认范围，避免除以零
                 if (maxPrice === minPrice) {
                     maxPrice += 1;
                     minPrice -= 1;
                 }
                 const safePriceRange = maxPrice - minPrice; // 确保价格范围大于零


                // 时间范围 (用于确定 X 轴的缩放比例)，与成交量图共享
                const startTime = klineData[0].time.getTime();
                const endTime = klineData[klineData.length - 1].time.getTime();
                const timeRange = endTime - startTime;

                 // 避免 timeRange 为零的情况
                 const safeTimeRange = timeRange > 0 ? timeRange : 1; // 确保不会除以零


                // 将价格转换为 Canvas 上的 Y 坐标
                function priceToY(price) {
                    // 确保价格在范围内，防止 NaN 或 Infinity
                    const clampedPrice = Math.max(minPrice, Math.min(maxPrice, price));
                    // Y 轴方向向下，所以价格越高，Y 坐标越小
                    return margin.top + klineChartHeight - ((clampedPrice - minPrice) / safePriceRange * klineChartHeight);
                }

                // 将时间转换为 Canvas 上的 X 坐标
                function timeToX(time) {
                     const timeStamp = time.getTime();
                    // 确保时间在范围内
                    const clampedTime = Math.max(startTime, Math.min(endTime, timeStamp));
                    // X 轴方向向右，时间越晚，X 坐标越大
                    return margin.left + ((clampedTime - startTime) / safeTimeRange * chartWidth);
                }

                // 绘制网格线和坐标轴标签
                drawGridAndAxes(klineCtx, 'price', priceToY, timeToX, maxPrice, minPrice, startTime, endTime, chartWidth, klineChartHeight, margin, currentTimeframe);

                // 绘制技术指标 (如果激活)
                if (activeIndicators.includes('ma')) {
                    drawMA(priceToY, timeToX, klineData, klineCtx, margin, chartWidth);
                }
                 if (activeIndicators.includes('boll')) {
                     drawBOLL(priceToY, timeToX, klineData, klineCtx, margin, chartWidth);
                 }
                 if (activeIndicators.includes('ema20') || activeIndicators.includes('ema83') || activeIndicators.includes('ema120')) {
                     drawEMA(priceToY, timeToX, klineData, klineCtx, margin, chartWidth, activeIndicators);
                 }
                 if (activeIndicators.includes('sar')) {
                     drawSAR(priceToY, timeToX, klineData, klineCtx, margin, chartWidth);
                 }


                // 根据当前选中的图表类型绘制 K 线图
                if (currentChartType === 'candle') {
                    drawCandles(priceToY, timeToX, klineData, klineCtx, chartWidth);
                } else if (currentChartType === 'line') {
                    drawLineChart(priceToY, timeToX, klineData, klineCtx, chartWidth);
                } else if (currentChartType === 'area') {
                    drawAreaChart(priceToY, timeToX, klineData, klineCtx, minPrice, safePriceRange, chartWidth, margin);
                }

                // 更新倒计时位置 (如果数据有效)
                if (klineData.length > 0) {
                     const lastItem = klineData[klineData.length - 1];
                     const barSpacing = chartWidth / klineData.length;
                     const offset = barSpacing / 2;
                     const lastBarX = margin.left + (klineData.length - 1) * barSpacing + offset;

                     // 将 Canvas 坐标转换为页面坐标
                     const klineCanvasRect = klineCanvas.getBoundingClientRect();
                     const chartWrapperRect = document.querySelector('.chart-wrapper').getBoundingClientRect();

                     const countdownX = klineCanvasRect.left - chartWrapperRect.left + lastBarX;
                     const countdownY = klineCanvasRect.top - chartWrapperRect.top + margin.top; // 放在 K 线图顶部附近

                     countdownTimerElement.style.left = `${countdownX}px`;
                     countdownTimerElement.style.top = `${countdownY}px`;
                     countdownTimerElement.style.display = 'block'; // 显示倒计时元素

                } else {
                    countdownTimerElement.style.display = 'none'; // 没有数据时隐藏倒计时
                }
            }

            // 绘制成交量图
            function drawVolumeChart() {
                 if (activeIndicators.includes('volume') && klineData.length > 0 && volumeCtx) {
                     // 计算最大成交量
                     let maxVolume = 0;
                     klineData.forEach(item => {
                         maxVolume = Math.max(maxVolume, item.volume);
                     });

                      // 如果最大成交量为零，给一个默认值防止除以零
                      const safeMaxVolume = maxVolume > 0 ? maxVolume : 1;

                     // 时间范围 (与K线图对齐)
                     const startTime = klineData[0].time.getTime();
                     const endTime = klineData[klineData.length - 1].time.getTime();
                      const timeRange = endTime - startTime;
                      const safeTimeRange = timeRange > 0 ? timeRange : 1; // 确保不会除以零

                     // 将时间转换为X坐标 (与K线图对齐)
                     function timeToX(time) {
                          const timeStamp = time.getTime();
                          const clampedTime = Math.max(startTime, Math.min(endTime, timeStamp));
                         // 注意：成交量图的 X 坐标需要基于其自身的 chartWidth 和 margin.left
                          // K线图和成交量图在同一个 chart-wrapper 内，水平对齐，所以 X 坐标转换逻辑可以共享
                          return margin.left + ((clampedTime - startTime) / safeTimeRange * chartWidth);
                     }

                      // 成交量转换为Y坐标
                      function volumeToY(volume) {
                          // 确保成交量在范围内
                          const clampedVolume = Math.max(0, Math.min(safeMaxVolume, volume));
                          // 注意：绘制柱状图是从底部开始绘制，所以 Y 坐标是 margin.top + volumeChartHeight - barHeight
                          return margin.top + volumeChartHeight - (clampedVolume / safeMaxVolume * volumeChartHeight);
                      }

                     // 清除成交量画布 (在绘制前清除，以便在鼠标移出时清除十字线垂直线)
                     volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);


                     // 绘制网格和坐标轴 (成交量图只需要简单的水平线和垂直轴标签)
                      drawGridAndAxes(volumeCtx, 'volume', volumeToY, timeToX, safeMaxVolume, 0, startTime, endTime, chartWidth, volumeChartHeight, margin, currentTimeframe, true); // true 表示绘制成交量轴标签


                     // 绘制成交量柱
                     const barSpacing = chartWidth / klineData.length; // 每个数据点占用的水平空间
                     const barWidth = Math.max(0.5, barSpacing * 0.8); // 确保柱子有最小宽度
                     const offset = barSpacing / 2; // 柱子中心相对于数据点起始位置的偏移量


                     klineData.forEach((item, index) => {
                         // 使用数据点的中心作为柱子的 X 坐标
                         const x = margin.left + (index * barSpacing) + offset; // 中心 x 坐标
                         const barLeft = x - barWidth / 2; // 柱子的左侧 x 坐标

                         const barHeight = (item.volume / safeMaxVolume) * volumeChartHeight;
                         const isUp = item.close >= item.open;

                         volumeCtx.fillStyle = isUp ? 'rgba(14, 203, 129, 0.6)' : 'rgba(246, 70, 93, 0.6)';
                         // 注意：绘制柱状图是从底部开始绘制，所以 Y 坐标是 margin.top + volumeChartHeight - barHeight
                         volumeCtx.fillRect(barLeft, margin.top + volumeChartHeight - barHeight, barWidth, barHeight);
                     });
                 } else if (volumeCtx) {
                     // 如果成交量不激活，清除其 Canvas
                     volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
                 }
            }

             // 绘制 MFI (资金流量指标) 图
             function drawMFIChart() {
                 // 只有当 MFI 指标被激活且数据长度足够时才绘制
                 if (activeIndicators.includes('mfi') && klineData.length >= 14 && mfiCtx) { // MFI 默认周期 14

                     // MFI 值范围通常在 0 到 100 之间
                     const maxMFI = 100;
                     const minMFI = 0;
                     const safeMFIRange = maxMFI - minMFI;

                     // 时间范围 (与 K 线图对齐)
                     const startTime = klineData[0].time.getTime();
                     const endTime = klineData[klineData.length - 1].time.getTime();
                     const timeRange = endTime - startTime;
                     const safeTimeRange = timeRange > 0 ? timeRange : 1;

                     // 将 MFI 值转换为 Y 坐标
                     function mfiToY(mfi) {
                         const clampedMFI = Math.max(minMFI, Math.min(maxMFI, mfi));
                         // Y 轴方向向下
                         return margin.top + mfiChartHeight - ((clampedMFI - minMFI) / safeMFIRange * mfiChartHeight);
                     }

                     // 将时间转换为 X 坐标 (与 K 线图对齐)
                     function timeToX(time) {
                          const timeStamp = time.getTime();
                          const clampedTime = Math.max(startTime, Math.min(endTime, timeStamp));
                          return margin.left + ((clampedTime - startTime) / safeTimeRange * chartWidth);
                     }

                     // 清除 MFI 画布
                     mfiCtx.clearRect(0, 0, mfiCanvas.width, mfiCanvas.height);

                     // 绘制网格和坐标轴 (MFI 图)
                     drawGridAndAxes(mfiCtx, 'mfi', mfiToY, timeToX, maxMFI, minMFI, startTime, endTime, chartWidth, mfiChartHeight, margin, currentTimeframe, true);


                     // 绘制 MFI 折线
                     mfiCtx.strokeStyle = '#f0b90b'; // MFI 线颜色
                     mfiCtx.lineWidth = 1;
                     mfiCtx.beginPath();

                     const barSpacing = chartWidth / klineData.length;
                     const offset = barSpacing / 2;


                     for (let i = 13; i < klineData.length; i++) { // 从第 14 个点开始有 MFI 值
                         const x = margin.left + (i * barSpacing) + offset; // 点的 X 坐标
                         const y = mfiToY(klineData[i].mfi); // 将 MFI 值转换为 Y 坐标

                         if (i === 13) {
                             mfiCtx.moveTo(x, y);
                         } else {
                             mfiCtx.lineTo(x, y);
                         }
                     }
                     mfiCtx.stroke();

                     // 绘制 MFI 的参考线 (例如 20 和 80)
                     mfiCtx.strokeStyle = '#848e9c';
                     mfiCtx.setLineDash([2, 2]); // 虚线
                     mfiCtx.lineWidth = 1;

                     // 绘制 20 线
                     const y20 = mfiToY(20);
                     mfiCtx.beginPath();
                     mfiCtx.moveTo(margin.left, y20);
                     mfiCtx.lineTo(margin.left + chartWidth, y20);
                     mfiCtx.stroke();
                     mfiCtx.fillText('20', margin.left - 20, y20); // 标签

                     // 绘制 80 线
                     const y80 = mfiToY(80);
                     mfiCtx.beginPath();
                     mfiCtx.moveTo(margin.left, y80);
                     mfiCtx.lineTo(margin.left + chartWidth, y80);
                     mfiCtx.stroke();
                     mfiCtx.fillText('80', margin.left - 20, y80); // 标签

                     mfiCtx.setLineDash([]); // 恢复实线

                     // 添加图例/标签 (只显示最后一个点的数值)
                     const lastItem = klineData[klineData.length - 1];
                     if (lastItem && lastItem.mfi !== undefined && !isNaN(lastItem.mfi)) {
                         const labelText = `MFI(14): ${lastItem.mfi.toFixed(2)}`;
                         const labelX = margin.left + chartWidth - 80; // 右侧区域
                         const labelY = margin.top + 15; // 顶部区域

                         mfiCtx.fillStyle = '#f0b90b';
                         mfiCtx.font = '10px Arial';
                         mfiCtx.textAlign = 'left';
                         mfiCtx.textBaseline = 'top';
                         mfiCtx.fillText(labelText, labelX, labelY);
                     }
                 } else if (mfiCtx) {
                     // 如果 MFI 不激活，清除其 Canvas
                     mfiCtx.clearRect(0, 0, mfiCanvas.width, mfiCanvas.height);
                 }
             }


             // 绘制 OBV (能量潮) 图
             function drawOBVChart() {
                 // 只有当 OBV 指标被激活且数据长度足够时才绘制
                 if (activeIndicators.includes('obv') && klineData.length > 0 && obvCtx) {

                     // 计算 OBV 值的范围
                     let maxOBV = -Infinity;
                     let minOBV = Infinity;
                     klineData.forEach(item => {
                         if (item.obv !== undefined && !isNaN(item.obv)) {
                            maxOBV = Math.max(maxOBV, item.obv);
                            minOBV = Math.min(minOBV, item.obv);
                         }
                     });

                     // 如果 OBV 范围为零，给一个默认范围
                     if (maxOBV === minOBV) {
                         maxOBV += 1;
                         minOBV -= 1;
                     }
                     const safeOBVRange = maxOBV - minOBV;


                     // 时间范围 (与 K 线图对齐)
                     const startTime = klineData[0].time.getTime();
                     const endTime = klineData[klineData.length - 1].time.getTime();
                     const timeRange = endTime - startTime;
                     const safeTimeRange = timeRange > 0 ? timeRange : 1;

                     // 将 OBV 值转换为 Y 坐标
                     function obvToY(obv) {
                         const clampedOBV = Math.max(minOBV, Math.min(maxOBV, obv));
                         // Y 轴方向向下
                         return margin.top + obvChartHeight - ((clampedOBV - minOBV) / safeOBVRange * obvChartHeight);
                     }

                     // 将时间转换为 X 坐标 (与 K 线图对齐)
                     function timeToX(time) {
                          const timeStamp = time.getTime();
                          const clampedTime = Math.max(startTime, Math.min(endTime, timeStamp));
                          return margin.left + ((clampedTime - startTime) / safeTimeRange * chartWidth);
                     }

                     // 清除 OBV 画布
                     obvCtx.clearRect(0, 0, obvCanvas.width, obvCanvas.height);

                     // 绘制网格和坐标轴 (OBV 图)
                     drawGridAndAxes(obvCtx, 'obv', obvToY, timeToX, maxOBV, minOBV, startTime, endTime, chartWidth, obvChartHeight, margin, currentTimeframe, true);


                     // 绘制 OBV 折线
                     obvCtx.strokeStyle = '#0ecb81'; // OBV 线颜色
                     obvCtx.lineWidth = 1;
                     obvCtx.beginPath();

                     const barSpacing = chartWidth / klineData.length;
                     const offset = barSpacing / 2;


                     for (let i = 0; i < klineData.length; i++) {
                         const item = klineData[i];
                          // 确保 OBV 值存在且是有效数字
                          if (item.obv !== undefined && !isNaN(item.obv)) {
                             const x = margin.left + (i * barSpacing) + offset; // 点的 X 坐标
                             const y = obvToY(item.obv); // 将 OBV 值转换为 Y 坐标

                             if (i === 0) {
                                 obvCtx.moveTo(x, y);
                             } else {
                                 obvCtx.lineTo(x, y);
                             }
                          }
                     }
                     obvCtx.stroke();

                     // 添加图例/标签 (只显示最后一个点的数值)
                     const lastItem = klineData[klineData.length - 1];
                     if (lastItem && lastItem.obv !== undefined && !isNaN(lastItem.obv)) {
                         const labelText = `OBV: ${formatVolume(lastItem.obv)}`; // OBV 使用成交量格式化
                         const labelX = margin.left + chartWidth - 80; // 右侧区域
                         const labelY = margin.top + 15; // 顶部区域

                         obvCtx.fillStyle = '#0ecb81';
                         obvCtx.font = '10px Arial';
                         obvCtx.textAlign = 'left';
                         obvCtx.textBaseline = 'top';
                         obvCtx.fillText(labelText, labelX, labelY);
                     }
                 } else if (obvCtx) {
                     // 如果 OBV 不激活，清除其 Canvas
                     obvCtx.clearRect(0, 0, obvCanvas.width, obvCanvas.height);
                 }
             }


            // --- 主要图表绘制函数 (调用辅助绘制函数) ---

            // 绘制所有图表 (K线图, 成交量图, MFI 图, OBV 图)
            function drawCharts() {
                // 确保所有 Canvas 上下文和数据都有效
                if (!klineCtx || !volumeCtx || !mfiCtx || !obvCtx || !crosshairCtx || klineData.length === 0) {
                     console.warn("无法绘制图表，数据或上下文无效。");
                     countdownTimerElement.style.display = 'none'; // 隐藏倒计时
                     return;
                }

                // 清除所有 Canvas 内容，准备重新绘制
                klineCtx.clearRect(0, 0, klineCanvas.width, klineCanvas.height);
                volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
                mfiCtx.clearRect(0, 0, mfiCanvas.width, mfiCanvas.height);
                obvCtx.clearRect(0, 0, obvCanvas.width, obvCanvas.height);
                crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height); // 清除十字线 overlay


                // 重新计算图表绘制区域尺寸，应对窗口大小变化或 Canvas 尺寸变化
                const klineRect = klineCanvas.getBoundingClientRect();
                const volumeRect = volumeCanvas.getBoundingClientRect();
                const mfiRect = mfiCanvas.getBoundingClientRect();
                const obvRect = obvCanvas.getBoundingClientRect();
                const crosshairRect = crosshairOverlay.getBoundingClientRect();


                chartWidth = klineRect.width - margin.left - margin.right;
                klineChartHeight = klineRect.height - margin.top - margin.bottom;
                volumeChartHeight = volumeRect.height - margin.top - margin.bottom;
                mfiChartHeight = mfiRect.height - margin.top - margin.bottom;
                obvChartHeight = obvRect.height - margin.top - margin.bottom;

                totalChartHeight = crosshairRect.height; // overlay 高度即 chart-wrapper 总高度
                crosshairOverlayHeight = crosshairRect.height;


                // 绘制 K 线图主体和叠加指标
                drawKlineChart();

                // 绘制成交量图
                drawVolumeChart();

                // 绘制 MFI 图
                drawMFIChart();

                // 绘制 OBV 图
                drawOBVChart();
            }


            // --- 数据获取和主要逻辑函数 ---

            // 初始化 Canvas 尺寸并获取 2D 上下文
            function initCanvas() {
                // 获取设备像素比，用于在高分辨率屏幕上清晰绘制
                const dpr = window.devicePixelRatio || 1;

                // 获取 Canvas 元素的实际渲染尺寸 (CSS 尺寸)
                const klineRect = klineCanvas.getBoundingClientRect();
                const volumeRect = volumeCanvas.getBoundingClientRect();
                const mfiRect = mfiCanvas.getBoundingClientRect(); // 获取 MFI Canvas 尺寸
                const obvRect = obvCanvas.getBoundingClientRect(); // 获取 OBV Canvas 尺寸
                const crosshairRect = crosshairOverlay.getBoundingClientRect(); // 获取 overlay 尺寸

                // 设置 Canvas 的实际像素尺寸，并根据 DPR 进行缩放，提高清晰度
                // 同时设置 Canvas 的 style 尺寸，保持其在页面布局中的大小
                klineCanvas.width = klineRect.width * dpr;
                klineCanvas.height = klineRect.height * dpr;
                klineCanvas.style.width = klineRect.width + 'px';
                klineCanvas.style.height = klineRect.height + 'px';
                klineCtx = klineCanvas.getContext('2d');
                klineCtx.scale(dpr, dpr); // 缩放上下文以匹配 DPR

                 // 设置成交量图 Canvas 尺寸
                volumeCanvas.width = volumeRect.width * dpr;
                volumeCanvas.height = volumeRect.height * dpr;
                volumeCanvas.style.width = volumeRect.width + 'px';
                volumeCanvas.style.height = volumeRect.height + 'px';
                volumeCtx = volumeCanvas.getContext('2d');
                volumeCtx.scale(dpr, dpr);

                 // 设置 MFI 图 Canvas 尺寸
                 mfiCanvas.width = mfiRect.width * dpr;
                 mfiCanvas.height = mfiRect.height * dpr;
                 mfiCanvas.style.width = mfiRect.width + 'px';
                 mfiCanvas.style.height = mfiRect.height + 'px';
                 mfiCtx = mfiCanvas.getContext('2d');
                 mfiCtx.scale(dpr, dpr);

                 // 设置 OBV 图 Canvas 尺寸
                 obvCanvas.width = obvRect.width * dpr;
                 obvCanvas.height = obvRect.height * dpr;
                 obvCanvas.style.width = obvRect.width + 'px';
                 obvCanvas.style.height = obvRect.height + 'px';
                 obvCtx = obvCanvas.getContext('2d');
                 obvCtx.scale(dpr, dpr);


                 // 设置十字线 overlay Canvas 尺寸 (覆盖整个 chart-wrapper)
                crosshairOverlay.width = crosshairRect.width * dpr;
                crosshairOverlay.height = crosshairRect.height * dpr;
                crosshairOverlay.style.width = crosshairRect.width + 'px';
                crosshairOverlay.style.height = crosshairRect.height + 'px';
                crosshairCtx = crosshairOverlay.getContext('2d');
                crosshairCtx.scale(dpr, dpr);


                // 计算图表绘制区域尺寸 (Canvas 实际尺寸 / DPR - margin)，这是我们进行绘制的逻辑尺寸
                chartWidth = klineRect.width - margin.left - margin.right;
                klineChartHeight = klineRect.height - margin.top - margin.bottom;
                volumeChartHeight = volumeRect.height - margin.top - margin.bottom;
                mfiChartHeight = mfiRect.height - margin.top - margin.bottom;
                obvChartHeight = obvRect.height - margin.top - margin.bottom;

                totalChartHeight = crosshairRect.height; // overlay 高度即 chart-wrapper 总高度
                crosshairOverlayHeight = crosshairRect.height;


                // 确保所有 Canvas 上下文都已成功获取
                if (!klineCtx || !volumeCtx || !mfiCtx || !obvCtx || !crosshairCtx) {
                    console.error("无法获取 Canvas 上下文！请检查浏览器或环境兼容性。");
                     // 如果无法获取上下文，可以考虑显示一个错误消息给用户
                     loadingOverlay.querySelector('div').textContent = '加载失败: 无法初始化图表。';
                     loadingOverlay.style.display = 'flex';
                } else {
                     // 如果成功获取上下文，隐藏加载提示（如果之前显示了）
                     // loadingOverlay.style.display = 'none'; // 在获取数据后再隐藏更合适
                }
            }

            // 从币安 API 获取实时 BTC 价格
            async function getBinanceBTCPrice() {
                try {
                    const response = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT');
                    // 检查 HTTP 响应状态
                    if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    const price = parseFloat(data.price);

                    // 更新价格方向，用于价格数字的颜色变化
                    if (lastPrice > 0) { // 确保不是第一次加载
                        priceDirection = price > lastPrice ? 1 : (price < lastPrice ? -1 : 0);
                    }
                    lastPrice = price; // 更新上一次价格

                    // 更新页面上显示的价格
                    btcPriceElement.textContent = price.toFixed(2);
                    // 根据价格方向添加或移除 CSS 类
                    btcPriceElement.className = 'price ' +
                        (priceDirection === 1 ? 'price-up' :
                         priceDirection === -1 ? 'price-down' : '');

                    // 更新最后更新时间
                    lastUpdatedElement.textContent = `最后更新: ${new Date().toLocaleTimeString()}`;

                    return price; // 返回获取到的价格
                } catch (error) {
                    console.error('获取价格失败:', error);
                    // 显示错误状态
                    btcPriceElement.textContent = '--';
                    priceChangeElement.textContent = '--%';
                    priceChangeElement.className = 'price-change'; // 清除颜色类
                    lastUpdatedElement.textContent = '获取价格失败';
                    return null; // 返回 null 表示获取失败
                }
            }

            // 从币安 API 获取 K 线数据 (带缓存功能)
            async function getKlineData(interval = '1m', limit = 200) {
                // 尝试从缓存获取数据，如果存在则直接使用
                if (klineDataCache.has(interval)) {
                    console.log(`从缓存加载 K 线数据 (${interval})`);
                    klineData = klineDataCache.get(interval); // 更新当前使用的 K 线数据
                    calculateIndicators(); // 重新计算指标
                    drawCharts(); // 重新绘制图表
                    updateCountdownTime(); // 更新倒计时目标时间
                     loadingOverlay.style.display = 'none'; // 如果从缓存加载，隐藏loading
                    return klineData;
                }

                // 缓存中没有数据，显示加载提示并从 API 获取
                loadingOverlay.style.display = 'flex';
                loadingOverlay.querySelector('div').textContent = '加载中...'; // 重置加载文本


                try {
                    // 构建 API 请求 URL
                    const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${interval}&limit=${limit}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    // 检查返回的数据是否有效
                    if (!Array.isArray(data) || data.length === 0) {
                         throw new Error("获取到无效或空的K线数据");
                    }

                    // 处理原始 K 线数据，转换为更易于使用的对象格式
                    const fetchedData = data.map(item => ({
                        time: new Date(item[0]), // 开盘时间
                        open: parseFloat(item[1]), // 开盘价
                        high: parseFloat(item[2]), // 最高价
                        low: parseFloat(item[3]), // 最低价
                        close: parseFloat(item[4]), // 收盘价
                        volume: parseFloat(item[5]), // 成交量
                        // item[6] close time, item[7] quote asset volume, item[8] number of trades,
                        // item[9] taker buy base asset volume, item[10] taker buy quote asset volume, item[11] ignore
                    }));

                    klineData = fetchedData; // 更新当前使用的 K 线数据

                    // 将获取到的数据存入缓存
                    klineDataCache.set(interval, fetchedData);
                    console.log(`将 K 线数据 (${interval}) 存入缓存`);

                    // 计算当前 K 线周期内的价格变化百分比
                    if (klineData.length >= 2) {
                        // 使用最后一条 K 线的开盘价作为计算涨跌幅的基准更常见
                        const openPrice = klineData[klineData.length - 1].open;
                        const lastClose = klineData[klineData.length - 1].close;
                        // 避免除以零
                        const change = openPrice !== 0 ? ((lastClose - openPrice) / openPrice * 100).toFixed(2) : (lastClose - openPrice).toFixed(2);


                        priceChangeElement.textContent = `${change}%`;
                        // 根据涨跌幅更新类名，改变颜色
                        priceChangeElement.className = 'price-change ' +
                            (parseFloat(change) >= 0 ? 'price-up' : 'price-down');
                    } else {
                         priceChangeElement.textContent = '--%';
                         priceChangeElement.className = 'price-change'; // 清除颜色类
                    }


                    // 计算技术指标 (基于获取到的 K 线数据)
                    calculateIndicators();

                    // 绘制图表
                    drawCharts();

                    // 更新倒计时目标时间
                    updateCountdownTime();

                    // 隐藏加载提示
                    loadingOverlay.style.display = 'none';
                    return klineData; // 返回获取到的数据
                } catch (error) {
                    console.error('获取K线数据失败:', error);
                    // 显示加载失败信息
                    loadingOverlay.querySelector('div').textContent = `数据加载失败: ${error.message}`;
                    // 清空图表数据并尝试重新初始化画布 (可能尺寸变化)
                     klineData = []; // 清空数据
                     // 清除所有 Canvas 内容
                     if (klineCtx) klineCtx.clearRect(0, 0, klineCanvas.width, klineCanvas.height);
                     if (volumeCtx) volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
                     if (mfiCtx) mfiCtx.clearRect(0, 0, mfiCanvas.width, mfiCanvas.height);
                     if (obvCtx) obvCtx.clearRect(0, 0, obvCanvas.width, obvCanvas.height);
                     if (crosshairCtx) crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height); // 清除十字线 overlay
                     countdownTimerElement.style.display = 'none'; // 隐藏倒计时

                    return null; // 返回 null 表示获取失败
                }
            }

            // 计算并更新倒计时显示
            function updateCountdown() {
                if (!currentKlineCloseTime) {
                    countdownTimerElement.style.display = 'none'; // 没有目标时间则隐藏
                    return;
                }

                const now = new Date().getTime(); // 当前时间戳
                const timeLeft = currentKlineCloseTime - now; // 剩余毫秒数

                if (timeLeft <= 0) {
                    countdownTimerElement.textContent = '00:00'; // 倒计时结束
                    countdownTimerElement.style.display = 'none'; // 倒计时结束隐藏
                    // 倒计时结束时，可能需要立即刷新 K 线数据以获取新的未闭合 K 线
                    // getKlineData(currentTimeframe); // 自动刷新会处理
                    return;
                }

                // 计算剩余分钟和秒
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

                // 格式化显示 (例如 05:30)
                const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                countdownTimerElement.textContent = formattedTime;
                countdownTimerElement.style.display = 'block'; // 显示倒计时
            }

            // 根据当前时间周期和最后一条 K 线数据计算收盘时间
            function updateCountdownTime() {
                if (klineData.length === 0) {
                    currentKlineCloseTime = null;
                    countdownTimerElement.style.display = 'none';
                    return;
                }

                const lastKline = klineData[klineData.length - 1];
                const openTime = lastKline.time.getTime(); // 开盘时间戳

                let intervalMilliseconds;
                switch (currentTimeframe) {
                    case '1m': intervalMilliseconds = 1 * 60 * 1000; break;
                    case '5m': intervalMilliseconds = 5 * 60 * 1000; break;
                    case '15m': intervalMilliseconds = 15 * 60 * 1000; break;
                    case '1h': intervalMilliseconds = 1 * 60 * 60 * 1000; break;
                    case '4h': intervalMilliseconds = 4 * 60 * 60 * 1000; break;
                    case '1d': intervalMilliseconds = 24 * 60 * 60 * 1000; break;
                    default:
                        currentKlineCloseTime = null;
                        countdownTimerElement.style.display = 'none';
                        return;
                }

                // 收盘时间 = 开盘时间 + 间隔时间
                currentKlineCloseTime = openTime + intervalMilliseconds;

                // 启动或重启倒计时定时器
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                }
                // 每秒更新一次倒计时
                countdownInterval = setInterval(updateCountdown, 1000);

                // 立即更新一次倒计时显示
                updateCountdown();
            }


            // 设置十字线交互 (鼠标移动和移出事件)
            function setupCrosshair() {
                // 鼠标移动事件监听 (监听 chart-wrapper，因为 overlay 覆盖整个区域)
                const chartWrapper = document.querySelector('.chart-wrapper');
                chartWrapper.addEventListener('mousemove', (e) => {
                     // 确保 Canvas 上下文和数据都有效
                    if (!klineCtx || !volumeCtx || !mfiCtx || !obvCtx || !crosshairCtx || klineData.length === 0) {
                         crosshairInfo.style.display = 'none'; // 隐藏信息框
                         // 清除所有 Canvas 上的垂直线
                         drawCharts(); // 重新绘制所有图表，清除垂直线
                         return;
                    }

                    // 清除之前的十字线 (只清除 overlay Canvas 上的十字线)
                    crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height);

                    // 获取 chart-wrapper 在视口中的位置和尺寸
                    const wrapperRect = chartWrapper.getBoundingClientRect();
                    // 计算鼠标相对于 chart-wrapper 左上角的坐标
                    const x = e.clientX - wrapperRect.left;
                    const y = e.clientY - wrapperRect.top;

                    // 检查鼠标是否在整个 chart-wrapper 区域内
                    if (x < margin.left || x > wrapperRect.width - margin.right ||
                        y < margin.top || y > wrapperRect.height - margin.bottom) {
                         crosshairInfo.style.display = 'none'; // 鼠标移出图表区域，隐藏信息框
                         // 清除所有 Canvas 上的垂直线
                         drawCharts(); // 重新绘制所有图表，清除垂直线
                        return; // 鼠标移出区域，不绘制十字线
                    }


                    // ----- 查找最接近鼠标位置的数据点 -----

                    let closestItem = null;
                    let minDiff = Infinity; // 最小距离
                    let closestIndex = -1; // 最接近数据点的索引

                    const barSpacing = chartWidth / klineData.length; // 计算每个数据点在 Canvas 上占用的水平空间

                    klineData.forEach((item, index) => {
                        // 计算当前数据点中心在 Canvas 上的 X 坐标 (相对于 chart-wrapper 左上角)
                        const itemCenterX = margin.left + (index * barSpacing) + barSpacing / 2;
                        // 计算鼠标 X 坐标与数据点中心 X 坐标的距离
                        const diff = Math.abs(x - itemCenterX);

                        // 找到距离最小的数据点
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestItem = item;
                            closestIndex = index;
                        }
                    });

                    // ----- 绘制十字线和信息框 -----

                    if (closestItem) {
                         // 使用找到的最接近数据点中心在 Canvas 上的精确 X 坐标来绘制垂直线
                         const crosshairX = margin.left + (closestIndex * barSpacing) + barSpacing / 2;


                        // 绘制十字线 (在 overlay Canvas 上绘制)
                        // 水平线 Y 坐标使用鼠标当前的 Y 坐标 (相对于 chart-wrapper 顶部)
                        drawCrosshair(crosshairCtx, crosshairX, y, margin, chartWidth, totalChartHeight, closestItem, currentTimeframe);


                        // 显示并定位信息框
                        crosshairInfo.style.display = 'block';
                        // 定位信息框，使其跟随鼠标，并避免超出屏幕边界
                        const infoBoxWidth = crosshairInfo.offsetWidth;
                        const infoBoxHeight = crosshairInfo.offsetHeight;
                        let infoX = e.clientX + 15; // 初始位置在鼠标右侧偏移 15px
                        let infoY = e.clientY + 15; // 初始位置在鼠标下方偏移 15px

                        // 调整位置以防超出右边界
                        if (infoX + infoBoxWidth > window.innerWidth - 20) { // 留一些边距
                            infoX = e.clientX - infoBoxWidth - 15; // 改到鼠标左侧偏移
                        }
                         // 调整位置以防超出下边界
                         if (infoY + infoBoxHeight > window.innerHeight - 20) { // 留一些边距
                             infoY = e.clientY - infoBoxHeight - 15; // 改到鼠标上方偏移
                         }
                         // 调整位置以防超出左边界
                         if (infoX < 10) infoX = 10; // 最小左边距
                         // 调整位置以防超出上边界
                         if (infoY < 10) infoY = 10; // 最小上边距


                        crosshairInfo.style.left = `${infoX}px`; // 设置信息框的 left 属性
                        crosshairInfo.style.top = `${infoY}px`; // 设置信息框的 top 属性

                        // 构建信息框内容 (显示当前数据点的详细信息和指标值)
                        let infoContent = `
                            <div><span>时间:</span> ${closestItem.time.toLocaleString()}</div>
                            <div><span>开盘:</span> ${closestItem.open.toFixed(2)}</div>
                            <div><span>最高:</span> ${closestItem.high.toFixed(2)}</div>
                            <div><span>最低:</span> ${closestItem.low.toFixed(2)}</div>
                            <div><span>收盘:</span> ${closestItem.close.toFixed(2)}</div>
                        `;

                         // 添加激活的指标信息
                         if (activeIndicators.includes('volume') && closestItem.volume !== undefined && !isNaN(closestItem.volume)) {
                             infoContent += `<div><span>成交量:</span> ${formatVolume(closestItem.volume)}</div>`;
                         }

                         const maPeriods = [5, 10, 20];
                         if (activeIndicators.includes('ma')) {
                             maPeriods.forEach(period => {
                                 const maValue = closestItem[`ma${period}`];
                                 if (maValue !== undefined && !isNaN(maValue)) {
                                     infoContent += `<div><span>MA${period}:</span> ${maValue.toFixed(2)}</div>`;
                                 }
                             });
                         }

                         if (activeIndicators.includes('boll') && closestItem.bollMid !== undefined && !isNaN(closestItem.bollMid)) {
                             infoContent += `
                                 <div><span>BOLL(20):</span> ${closestItem.bollMid.toFixed(2)}</div>
                                 <div><span>上轨:</span> ${closestItem.bollUpper.toFixed(2)}</div>
                                 <div><span>下轨:</span> ${closestItem.bollLower.toFixed(2)}</div>
                             `;
                         }

                         const emaPeriods = [20, 83, 120];
                         emaPeriods.forEach(period => {
                             const emaValue = closestItem[`ema${period}`];
                              if (activeIndicators.includes(`ema${period}`) && emaValue !== undefined && !isNaN(emaValue)) {
                                 infoContent += `<div><span>EMA${period}:</span> ${emaValue.toFixed(2)}</div>`;
                              }
                         });

                          if (activeIndicators.includes('sar') && closestItem.sar !== undefined && !isNaN(closestItem.sar)) {
                              infoContent += `<div><span>SAR:</span> ${closestItem.sar.toFixed(2)}</div>`;
                          }

                          if (activeIndicators.includes('mfi') && closestItem.mfi !== undefined && !isNaN(closestItem.mfi)) {
                              infoContent += `<div><span>MFI(14):</span> ${closestItem.mfi.toFixed(2)}</div>`;
                          }

                          if (activeIndicators.includes('obv') && closestItem.obv !== undefined && !isNaN(closestItem.obv)) {
                              infoContent += `<div><span>OBV:</span> ${formatVolume(closestItem.obv)}</div>`;
                          }


                        crosshairInfo.innerHTML = infoContent; // 更新信息框内容

                    } else {
                        crosshairInfo.style.display = 'none'; // 没有找到最近数据点，隐藏信息框
                         // 清除所有 Canvas 上的垂直线
                         drawCharts(); // 重新绘制所有图表，清除垂直线
                    }
                });

                // 鼠标移出事件监听 (监听 chart-wrapper)
                chartWrapper.addEventListener('mouseout', () => {
                    // 清除十字线 overlay Canvas 内容和信息框
                    if (crosshairCtx) {
                         crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height);
                    }
                    crosshairInfo.style.display = 'none'; // 隐藏信息框
                     // 鼠标移出时，清除所有 Canvas 上的垂直线
                     drawCharts(); // 重新绘制所有图表，清除垂直线
                });

                 // 防止在 Canvas 上右键弹出浏览器默认菜单
                 chartWrapper.addEventListener('contextmenu', (e) => {
                     e.preventDefault();
                 });

                 // 当窗口大小变化时，隐藏十字线和信息框，并重新初始化 Canvas
                 window.addEventListener('resize', () => {
                     crosshairInfo.style.display = 'none'; // 隐藏信息框
                     if (crosshairCtx) {
                          crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height); // 清除十字线 overlay
                     }
                     // 窗口大小变化后重新初始化 Canvas 尺寸并重绘图表
                     initCanvas();
                     // 重新绘制当前缓存的数据 (或者重新获取数据，取决于需求)
                     if (klineDataCache.has(currentTimeframe)) {
                         klineData = klineDataCache.get(currentTimeframe);
                         calculateIndicators(); // 重新计算指标以适应新尺寸（如果指标计算依赖尺寸）
                         drawCharts(); // 重新绘制图表
                         updateCountdownTime(); // 更新倒计时目标时间
                     } else {
                         // 如果当前周期数据不在缓存（不应该发生，除非刚加载），重新获取
                          getKlineData(currentTimeframe);
                     }
                 });
            }


            // 自动刷新函数，定时获取最新价格和 K 线数据
            function startAutoRefresh(interval = 5000) { // 默认刷新间隔 5 秒
                // 清除现有定时器，避免重复启动
                if (refreshInterval) {
                    clearInterval(refreshInterval);
                }

                // 立即获取一次数据并启动定时器
                getBinanceBTCPrice(); // 获取实时价格
                // 首次加载或切换周期时，总是获取当前时间周期的 K 线数据（可能从缓存或 API）
                getKlineData(currentTimeframe);

                // 启动定时器，每隔指定间隔执行一次
                refreshInterval = setInterval(async () => {
                    // 在定时器中先获取最新价格
                    await getBinanceBTCPrice();
                    // 定时刷新时，重新获取当前时间周期的最新数据并更新图表
                    // 这会获取 limit 数量的最新数据，并重新绘制整个图表
                    getKlineData(currentTimeframe);
                }, interval); // 设置刷新间隔

                console.log(`开始自动刷新，间隔: ${interval}ms`);
            }

            // 页面加载完成后的初始化流程
            // 确保 DOM 元素都已加载
            document.addEventListener('DOMContentLoaded', () => {
                 initCanvas(); // 首次初始化 Canvas
                 setupCrosshair(); // 设置十字线交互
                 startAutoRefresh(); // 开始自动刷新

                 // 激活默认选中的时间周期和图表类型按钮
                 document.querySelector('.timeframe-tab.active').classList.add('active');
                 document.querySelector('.toolbar-btn[data-type].active').classList.add('active');
                 // 激活默认选中的指标按钮
                 activeIndicators.forEach(indicator => {
                     const btn = document.querySelector(`.toolbar-btn[data-indicator="${indicator}"]`);
                     if (btn) btn.classList.add('active');
                 });
            });


            // 时间周期切换事件监听
            timeframeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // 如果点击的是当前已激活的标签，则不执行任何操作
                    if (tab.classList.contains('active')) return;

                    // 移除所有时间周期标签的 active 类
                    timeframeTabs.forEach(t => t.classList.remove('active'));
                    // 给当前点击的标签添加 active 类
                    tab.classList.add('active');
                    // 更新当前选中的时间周期
                    currentTimeframe = tab.dataset.interval;
                    console.log(`切换时间周期到: ${currentTimeframe}`);
                    // 切换时间周期时，清除当前的自动刷新定时器和倒计时定时器
                    clearInterval(refreshInterval);
                    refreshInterval = null; // 清除引用
                    clearInterval(countdownInterval);
                    countdownInterval = null; // 清除引用
                    countdownTimerElement.style.display = 'none'; // 隐藏倒计时

                    // 获取新时间周期的 K 线数据（可能从缓存或 API）
                    getKlineData(currentTimeframe);
                    // 重新开始自动刷新（新的定时器会获取当前周期的数据）
                    startAutoRefresh();
                });
            });

            // 图表类型切换事件监听
            chartTypeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    // 如果点击的是当前已激活的按钮，则不执行任何操作
                    if (btn.classList.contains('active')) return;

                    // 移除所有图表类型按钮的 active 类
                    chartTypeBtns.forEach(b => b.classList.remove('active'));
                    // 给当前点击的按钮添加 active 类
                    btn.classList.add('active');
                    // 更新当前选中的图表类型
                    currentChartType = btn.dataset.type;
                    console.log(`切换图表类型到: ${currentChartType}`);
                     // 切换图表类型只需根据当前数据重新绘制，不需要重新获取数据或计算指标
                    drawCharts();
                });
            });

            // 技术指标切换事件监听
            indicatorBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const indicator = btn.dataset.indicator; // 获取点击的指标类型
                    const index = activeIndicators.indexOf(indicator); // 查找指标是否已激活

                    if (index === -1) { // 如果指标未激活
                        // 添加到激活指标列表
                         activeIndicators.push(indicator);
                         btn.classList.add('active'); // 添加 active 类
                         console.log(`添加技术指标: ${indicator}`);

                    } else { // 如果指标已激活
                        activeIndicators.splice(index, 1); // 从激活指标列表中移除
                        btn.classList.remove('active'); // 移除 active 类
                        console.log(`移除技术指标: ${indicator}`);
                    }

                    // 重新计算所有激活的指标 (基于当前的 klineData)
                    calculateIndicators();
                    // 重新绘制图表以显示/隐藏指标线和面板
                    drawCharts();
                });
            });

            // 页面可见性变化事件监听，用于在页面隐藏时停止刷新，页面可见时恢复刷新
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // 页面不可见时清除定时器
                    if (refreshInterval) {
                       clearInterval(refreshInterval);
                       refreshInterval = null; // 清除引用
                       console.log("页面隐藏，停止自动刷新。");
                    }
                     if (countdownInterval) {
                         clearInterval(countdownInterval);
                         countdownInterval = null; // 清除引用
                         console.log("页面隐藏，停止倒计时。");
                     }
                } else {
                    // 页面可见时重新开始定时刷新和倒计时
                    if (!refreshInterval) { // 确保没有重复启动定时器
                        startAutoRefresh();
                        console.log("页面可见，恢复自动刷新。");
                    }
                     if (!countdownInterval && currentKlineCloseTime) { // 确保没有重复启动定时器且有目标时间
                         countdownInterval = setInterval(updateCountdown, 1000);
                         console.log("页面可见，恢复倒计时。");
                     }
                }
            });

            // 初始加载时，如果数据加载失败，提供刷新按钮（可选）
            loadingOverlay.addEventListener('click', () => {
                 if (loadingOverlay.querySelector('div').textContent.includes('失败')) {
                     window.location.reload(); // 点击失败提示时刷新页面
                 }
            });

        })(); // IIFE 结束
    </script>
</body>
</html>
