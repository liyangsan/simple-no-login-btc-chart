<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC实时价格与专业K线图</title>
    <style>
        /* 基本样式，保持与之前一致 */
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e222d;
            color: #eaecef;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .price-header {
            background-color: #2a2e39;
            border-radius: 4px;
            padding: 15px 20px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .price-info {
            display: flex;
            align-items: center;
        }
        .symbol {
            font-size: 18px;
            font-weight: bold;
            margin-right: 15px;
            color: #f0b90b;
        }
        .price {
            font-size: 24px;
            font-weight: bold;
            margin-right: 10px;
        }
        .price-up {
            color: #0ecb81;
        }
        .price-down {
            color: #f6465d;
        }
        .price-change {
            font-size: 14px;
            padding: 2px 6px;
            border-radius: 2px;
        }
        .price-up .price-change {
            background-color: rgba(14, 203, 129, 0.2);
            color: #0ecb81;
        }
         .price-down .price-change {
            background-color: rgba(246, 70, 93, 0.2);
            color: #f6465d;
        }
        .last-updated {
            font-size: 12px;
            color: #848e9c;
        }
        .chart-container {
            background-color: #2a2e39;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .chart-title {
            font-size: 16px;
            font-weight: bold;
        }
        .timeframe-tabs {
            display: flex;
            background-color: #1e222d;
            border-radius: 4px;
            padding: 2px;
        }
        .timeframe-tab {
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 2px;
            transition: background-color 0.2s ease;
        }
        .timeframe-tab:hover {
             background-color: #373c49;
        }
        .timeframe-tab.active {
            background-color: #2a2e39;
            color: #f0b90b;
        }
        .chart-wrapper {
            position: relative;
            height: 500px; /* 可以根据需要调整高度 */
            /* 确保 chart-wrapper 有明确的尺寸，Canvas 才能基于它计算 */
            width: 100%;
        }
        #klineChart {
            width: 100%;
            height: calc(100% - 110px); /* 为成交量图腾出空间 */
            display: block; /* 防止底部出现空白 */
        }
         #volumeChart {
            width: 100%;
            height: 100px; /* 成交量图高度 */
            display: block; /* 防止底部出现空白 */
             margin-top: 10px;
        }
         /* 新增一个用于绘制十字线的透明 overlay Canvas */
        #crosshairOverlay {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: calc(100% - 110px); /* 与 klineChart 同高 */
             z-index: 5; /* 在 K线图之上，Loading 之下 */
             pointer-events: none; /* 允许鼠标事件穿透到下层 canvas */
        }

        .toolbar {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
             flex-wrap: wrap; /* 换行以适应小屏幕 */
        }
        .toolbar-group {
            display: flex;
            gap: 5px;
             margin-bottom: 5px; /* 添加底部间距，防止换行后粘连 */
        }
        .toolbar-btn {
            background-color: #373c49;
            border: none;
            color: #eaecef;
            padding: 5px 10px;
            border-radius: 2px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .toolbar-btn:hover {
            background-color: #4a4f5e;
        }
        .toolbar-btn.active {
            background-color: #f0b90b;
            color: #1e222d;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 34, 45, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            color: #f0b90b;
            font-size: 18px;
        }
        .crosshair-info {
            position: fixed; /* 使用 fixed 定位，避免受父元素滚动影响 */
            background-color: rgba(42, 46, 57, 0.9);
            border: 1px solid #373c49;
            padding: 5px 8px;
            font-size: 12px;
            pointer-events: none; /* 允许鼠标事件穿透 */
            z-index: 15; /* 确保在加载层之上 */
            display: none;
            border-radius: 4px;
            color: #eaecef;
            line-height: 1.5;
            white-space: nowrap; /* 防止信息框内容换行 */
        }
         .crosshair-info div span:first-child {
             color: #848e9c; /* 标签颜色 */
             display: inline-block;
             width: 60px; /* 标签固定宽度，稍微增加以容纳中文 */
             margin-right: 5px; /* 标签和值之间的间距 */
         }
    </style>
</head>
<body>
    <div class="container">
        <div class="price-header">
            <div class="price-info">
                <div class="symbol">BTC/USDT</div>
                <div class="price" id="btcPrice">--</div>
                <div class="price-change" id="priceChange">--%</div>
            </div>
            <div class="last-updated" id="lastUpdated">最后更新: --</div>
        </div>

        <div class="chart-container">
            <div class="chart-header">
                <div class="chart-title">K线图</div>
                <div class="timeframe-tabs">
                    <div class="timeframe-tab active" data-interval="1m">1分</div>
                    <div class="timeframe-tab" data-interval="5m">5分</div>
                    <div class="timeframe-tab" data-interval="15m">15分</div>
                    <div class="timeframe-tab" data-interval="1h">1小时</div>
                    <div class="timeframe-tab" data-interval="4h">4小时</div>
                    <div class="timeframe-tab" data-interval="1d">1日</div>
                </div>
            </div>

            <div class="chart-wrapper">
                <canvas id="klineChart"></canvas>
                 <canvas id="volumeChart"></canvas>
                <canvas id="crosshairOverlay"></canvas>

                <div class="loading-overlay" id="loadingOverlay">
                    <div>加载中...</div>
                </div>
            </div>

            <div class="toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn active" data-type="candle">蜡烛</button>
                    <button class="toolbar-btn" data-type="line">折线</button>
                    <button class="toolbar-btn" data-type="area">面积</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn active" data-indicator="ma">MA</button> <button class="toolbar-btn" data-indicator="ema">EMA</button>
                    <button class="toolbar-btn" data-indicator="macd">MACD</button>
                    <button class="toolbar-btn" data-indicator="rsi">RSI</button>
                </div>
            </div>
        </div>
         <div class="crosshair-info" id="crosshairInfo"></div>
    </div>

    <script>
        // 使用 IIFE 包裹代码，创建独立作用域，避免全局变量污染
        (function() {
            // DOM元素引用
            const btcPriceElement = document.getElementById('btcPrice');
            const priceChangeElement = document.getElementById('priceChange');
            const lastUpdatedElement = document.getElementById('lastUpdated');
            const klineCanvas = document.getElementById('klineChart');
            const volumeCanvas = document.getElementById('volumeChart');
            const crosshairOverlay = document.getElementById('crosshairOverlay'); // 用于绘制十字线的透明 Canvas
            const timeframeTabs = document.querySelectorAll('.timeframe-tab');
            const chartTypeBtns = document.querySelectorAll('.toolbar-btn[data-type]');
            const indicatorBtns = document.querySelectorAll('.toolbar-btn[data-indicator]');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const crosshairInfo = document.getElementById('crosshairInfo');

            // 图表上下文
            let klineCtx = null;
            let volumeCtx = null;
            let crosshairCtx = null; // 十字线 Canvas 的上下文

            // 数据状态
            let klineData = []; // 当前时间周期下的 K 线数据
            let currentTimeframe = '1m'; // 当前选中的时间周期
            let currentChartType = 'candle'; // 当前选中的图表类型
            let activeIndicators = ['ma']; // 当前激活的技术指标 (MA 默认激活)
            let refreshInterval = null; // 自动刷新定时器 ID
            let lastPrice = 0; // 上一次获取的 BTC 价格，用于判断涨跌
            let priceDirection = 0; // 价格方向: 0: 无变化, 1: 上涨, -1: 下跌

            // K线数据缓存 { timeframe: data[] }，避免重复请求相同周期的数据
            const klineDataCache = new Map();

            // 图表配置和尺寸 (根据实际 canvas 尺寸计算)
            // 调整右侧和底部留白用于坐标轴标签
            const margin = { top: 20, right: 60, bottom: 30, left: 50 };
            let chartWidth = 0; // K 线图绘制区域宽度
            let chartHeight = 0; // K 线图绘制区域高度
            let volumeChartHeight = 0; // 成交量图绘制区域高度
            let crosshairOverlayHeight = 0; // 十字线 overlay 高度


            // 初始化 Canvas 尺寸并获取 2D 上下文
            function initCanvas() {
                // 获取设备像素比，用于在高分辨率屏幕上清晰绘制
                const dpr = window.devicePixelRatio || 1;

                // 获取 Canvas 元素的实际渲染尺寸 (CSS 尺寸)
                const klineRect = klineCanvas.getBoundingClientRect();
                const volumeRect = volumeCanvas.getBoundingClientRect();
                const crosshairRect = crosshairOverlay.getBoundingClientRect();

                // 设置 Canvas 的实际像素尺寸，并根据 DPR 进行缩放，提高清晰度
                // 同时设置 Canvas 的 style 尺寸，保持其在页面布局中的大小
                klineCanvas.width = klineRect.width * dpr;
                klineCanvas.height = klineRect.height * dpr;
                klineCanvas.style.width = klineRect.width + 'px';
                klineCanvas.style.height = klineRect.height + 'px';
                klineCtx = klineCanvas.getContext('2d');
                klineCtx.scale(dpr, dpr); // 缩放上下文以匹配 DPR

                 // 设置成交量图 Canvas 尺寸
                volumeCanvas.width = volumeRect.width * dpr;
                volumeCanvas.height = volumeRect.height * dpr;
                volumeCanvas.style.width = volumeRect.width + 'px';
                volumeCanvas.style.height = volumeRect.height + 'px';
                volumeCtx = volumeCanvas.getContext('2d');
                volumeCtx.scale(dpr, dpr);

                 // 设置十字线 overlay Canvas 尺寸
                crosshairOverlay.width = crosshairRect.width * dpr;
                crosshairOverlay.height = crosshairRect.height * dpr;
                crosshairOverlay.style.width = crosshairRect.width + 'px';
                crosshairOverlay.style.height = crosshairRect.height + 'px';
                crosshairCtx = crosshairOverlay.getContext('2d');
                crosshairCtx.scale(dpr, dpr);


                // 计算图表绘制区域尺寸 (Canvas 实际尺寸 / DPR - margin)，这是我们进行绘制的逻辑尺寸
                chartWidth = klineRect.width - margin.left - margin.right;
                chartHeight = klineRect.height - margin.top - margin.bottom;
                // 成交量图使用相同的左右 margin 以水平对齐
                volumeChartHeight = volumeRect.height - margin.top - margin.bottom;
                // 十字线 overlay 的高度与 K线图绘制区域高度一致
                crosshairOverlayHeight = klineRect.height;


                // 确保所有 Canvas 上下文都已成功获取
                if (!klineCtx || !volumeCtx || !crosshairCtx) {
                    console.error("无法获取 Canvas 上下文！请检查浏览器或环境兼容性。");
                     // 如果无法获取上下文，可以考虑显示一个错误消息给用户
                     loadingOverlay.querySelector('div').textContent = '加载失败: 无法初始化图表。';
                     loadingOverlay.style.display = 'flex';
                } else {
                     // 如果成功获取上下文，隐藏加载提示（如果之前显示了）
                     // loadingOverlay.style.display = 'none'; // 在获取数据后再隐藏更合适
                }
            }

            // 从币安 API 获取实时 BTC 价格
            async function getBinanceBTCPrice() {
                try {
                    const response = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT');
                    // 检查 HTTP 响应状态
                    if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    const price = parseFloat(data.price);

                    // 更新价格方向，用于价格数字的颜色变化
                    if (lastPrice > 0) { // 确保不是第一次加载
                        priceDirection = price > lastPrice ? 1 : (price < lastPrice ? -1 : 0);
                    }
                    lastPrice = price; // 更新上一次价格

                    // 更新页面上显示的价格
                    btcPriceElement.textContent = price.toFixed(2);
                    // 根据价格方向添加或移除 CSS 类
                    btcPriceElement.className = 'price ' +
                        (priceDirection === 1 ? 'price-up' :
                         priceDirection === -1 ? 'price-down' : '');

                    // 更新最后更新时间
                    lastUpdatedElement.textContent = `最后更新: ${new Date().toLocaleTimeString()}`;

                    return price; // 返回获取到的价格
                } catch (error) {
                    console.error('获取价格失败:', error);
                    // 显示错误状态
                    btcPriceElement.textContent = '--';
                    priceChangeElement.textContent = '--%';
                    priceChangeElement.className = 'price-change'; // 清除颜色类
                    lastUpdatedElement.textContent = '获取价格失败';
                    return null; // 返回 null 表示获取失败
                }
            }

            // 从币安 API 获取 K 线数据 (带缓存功能)
            async function getKlineData(interval = '1m', limit = 200) {
                // 尝试从缓存获取数据，如果存在则直接使用
                if (klineDataCache.has(interval)) {
                    console.log(`从缓存加载 K 线数据 (${interval})`);
                    klineData = klineDataCache.get(interval); // 更新当前使用的 K 线数据
                    calculateIndicators(); // 重新计算指标
                    drawCharts(); // 重新绘制图表
                     loadingOverlay.style.display = 'none'; // 如果从缓存加载，隐藏loading
                    return klineData;
                }

                // 缓存中没有数据，显示加载提示并从 API 获取
                loadingOverlay.style.display = 'flex';
                loadingOverlay.querySelector('div').textContent = '加载中...'; // 重置加载文本


                try {
                    // 构建 API 请求 URL
                    const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${interval}&limit=${limit}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    // 检查返回的数据是否有效
                    if (!Array.isArray(data) || data.length === 0) {
                         throw new Error("获取到无效或空的K线数据");
                    }

                    // 处理原始 K 线数据，转换为更易于使用的对象格式
                    const fetchedData = data.map(item => ({
                        time: new Date(item[0]), // 开盘时间
                        open: parseFloat(item[1]), // 开盘价
                        high: parseFloat(item[2]), // 最高价
                        low: parseFloat(item[3]), // 最低价
                        close: parseFloat(item[4]), // 收盘价
                        volume: parseFloat(item[5]), // 成交量
                        // item[6] close time, item[7] quote asset volume, item[8] number of trades,
                        // item[9] taker buy base asset volume, item[10] taker buy quote asset volume, item[11] ignore
                    }));

                    klineData = fetchedData; // 更新当前使用的 K 线数据

                    // 将获取到的数据存入缓存
                    klineDataCache.set(interval, fetchedData);
                    console.log(`将 K 线数据 (${interval}) 存入缓存`);

                    // 计算当前 K 线周期内的价格变化百分比
                    if (klineData.length >= 2) {
                        // 使用最后一条 K 线的开盘价作为计算涨跌幅的基准更常见
                        const openPrice = klineData[klineData.length - 1].open;
                        const lastClose = klineData[klineData.length - 1].close;
                        // 避免除以零
                        const change = openPrice !== 0 ? ((lastClose - openPrice) / openPrice * 100).toFixed(2) : (lastClose - openPrice).toFixed(2);


                        priceChangeElement.textContent = `${change}%`;
                        // 根据涨跌幅更新类名，改变颜色
                        priceChangeElement.className = 'price-change ' +
                            (parseFloat(change) >= 0 ? 'price-up' : 'price-down');
                    } else {
                         priceChangeElement.textContent = '--%';
                         priceChangeElement.className = 'price-change'; // 清除颜色类
                    }


                    // 计算技术指标 (基于获取到的 K 线数据)
                    calculateIndicators();

                    // 绘制图表
                    drawCharts();

                    // 隐藏加载提示
                    loadingOverlay.style.display = 'none';
                    return klineData; // 返回获取到的数据
                } catch (error) {
                    console.error('获取K线数据失败:', error);
                    // 显示加载失败信息
                    loadingOverlay.querySelector('div').textContent = `数据加载失败: ${error.message}`;
                    // 清空图表数据并尝试重新初始化画布 (可能尺寸变化)
                     klineData = []; // 清空数据
                     // 清除 Canvas 内容
                     if (klineCtx) klineCtx.clearRect(0, 0, klineCanvas.width, klineCanvas.height);
                     if (volumeCtx) volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
                     if (crosshairCtx) crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height); // 清除十字线 overlay

                    return null; // 返回 null 表示获取失败
                }
            }

            // 计算技术指标 (目前只实现了 MA)
            function calculateIndicators() {
                // 在此处添加各种技术指标计算逻辑，计算结果直接添加到 klineData 的每个 item 中
                const periods = [5, 10, 20]; // MA 指标的计算周期

                // 先移除旧的 MA 数据，避免重复计算或残留
                klineData.forEach(item => periods.forEach(period => delete item[`ma${period}`]));

                // 计算 MA (简单移动平均线)
                if (activeIndicators.includes('ma') && klineData.length > 0) {
                    periods.forEach(period => {
                         // 确保数据长度足够计算当前周期的 MA
                         if (klineData.length >= period) {
                             for (let i = period - 1; i < klineData.length; i++) {
                                 let sum = 0;
                                 for (let j = 0; j < period; j++) {
                                     sum += klineData[i - j].close; // 使用收盘价计算 MA
                                 }
                                 klineData[i][`ma${period}`] = sum / period; // 将计算结果存储在数据项中
                             }
                         }
                    });
                }


                // EMA (指数移动平均线) - 占位符，需要实际实现
                 // 移除旧的 EMA 数据
                 klineData.forEach(item => delete item.ema); // 示例，可能需要多个周期 EMA
                 if (activeIndicators.includes('ema')) {
                    // 实现 EMA 计算逻辑...
                    // console.log("EMA 计算逻辑待实现");
                 }


                // MACD (移动平均聚散指标) - 占位符，需要实际实现
                 // 移除旧的 MACD 数据
                 klineData.forEach(item => { delete item.macdLine; delete item.signalLine; delete item.histogram; });
                 if (activeIndicators.includes('macd')) {
                    // 实现 MACD 计算逻辑...
                     // console.log("MACD 计算逻辑待实现");
                 }

                // RSI (相对强弱指数) - 占位符，需要实际实现
                 // 移除旧的 RSI 数据
                 klineData.forEach(item => delete item.rsi);
                 if (activeIndicators.includes('rsi')) {
                    // 实现 RSI 计算逻辑...
                     // console.log("RSI 计算逻辑待实现");
                 }
            }

            // 绘制 K 线图和成交量图
            function drawCharts() {
                // 确保 Canvas 上下文和数据都有效
                if (!klineCtx || !volumeCtx || !crosshairCtx || klineData.length === 0) {
                     console.warn("无法绘制图表，数据或上下文无效。");
                     return;
                }

                // 清除画布内容，准备重新绘制
                klineCtx.clearRect(0, 0, klineCanvas.width, klineCanvas.height);
                volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
                crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height); // 清除十字线 overlay


                // 重新计算图表绘制区域尺寸，应对窗口大小变化或 Canvas 尺寸变化
                const klineRect = klineCanvas.getBoundingClientRect();
                const volumeRect = volumeCanvas.getBoundingClientRect();
                // crosshairRect 与 klineRect 尺寸一致，无需重新获取

                chartWidth = klineRect.width - margin.left - margin.right;
                chartHeight = klineRect.height - margin.top - margin.bottom;
                volumeChartHeight = volumeRect.height - margin.top - margin.bottom; // 使用相同的top/bottom margin for alignment
                crosshairOverlayHeight = klineRect.height; // 十字线 overlay 高度与 K线图 Canvas 高度一致


                // 绘制 K 线图主体
                drawKlineChart();

                // 绘制成交量图
                drawVolumeChart();
            }

            // 绘制 K 线图
            function drawKlineChart() {
                if (klineData.length === 0 || !klineCtx) return;

                // 计算价格范围 (用于确定 Y 轴的缩放比例)
                let maxPrice = -Infinity;
                let minPrice = Infinity;

                klineData.forEach(item => {
                    // 考虑 K 线的最高价和最低价
                    maxPrice = Math.max(maxPrice, item.high);
                    minPrice = Math.min(minPrice, item.low);
                     // 考虑激活的 MA 指标的最大最小值，确保所有绘制元素都在图表范围内
                     if (activeIndicators.includes('ma')) {
                         const periods = [5, 10, 20];
                         periods.forEach(period => {
                             if (item[`ma${period}`] !== undefined && !isNaN(item[`ma${period}`])) {
                                 maxPrice = Math.max(maxPrice, item[`ma${period}`]);
                                 minPrice = Math.min(minPrice, item[`ma${period}`]);
                             }
                         });
                     }
                    // TODO: 考虑其他指标的最大最小值
                });

                // 添加一些 padding，防止最高最低价紧贴图表边界
                const priceRange = maxPrice - minPrice;
                const pricePadding = priceRange * 0.1; // 10% padding
                maxPrice += pricePadding;
                minPrice -= pricePadding;

                // 如果价格范围为零（所有价格相同），给一个默认范围，避免除以零
                 if (maxPrice === minPrice) {
                     maxPrice += 1;
                     minPrice -= 1;
                 }
                 const safePriceRange = maxPrice - minPrice; // 确保价格范围大于零


                // 时间范围 (用于确定 X 轴的缩放比例)，与成交量图共享
                const startTime = klineData[0].time.getTime();
                const endTime = klineData[klineData.length - 1].time.getTime();
                const timeRange = endTime - startTime;

                 // 避免 timeRange 为零的情况
                 const safeTimeRange = timeRange > 0 ? timeRange : 1; // 确保不会除以零


                // 将价格转换为 Canvas 上的 Y 坐标
                function priceToY(price) {
                    // 确保价格在范围内，防止 NaN 或 Infinity
                    const clampedPrice = Math.max(minPrice, Math.min(maxPrice, price));
                    // Y 轴方向向下，所以价格越高，Y 坐标越小
                    return margin.top + chartHeight - ((clampedPrice - minPrice) / safePriceRange * chartHeight);
                }

                // 将时间转换为 Canvas 上的 X 坐标
                function timeToX(time) {
                     const timeStamp = time.getTime();
                    // 确保时间在范围内
                    const clampedTime = Math.max(startTime, Math.min(endTime, timeStamp));
                    // X 轴方向向右，时间越晚，X 坐标越大
                    return margin.left + ((clampedTime - startTime) / safeTimeRange * chartWidth);
                }

                // 绘制网格线和坐标轴标签
                drawGridAndAxes(klineCtx, 'price', priceToY, timeToX, maxPrice, minPrice, startTime, endTime, chartWidth, chartHeight, margin, currentTimeframe);

                // 绘制技术指标 (如果激活)
                if (activeIndicators.includes('ma')) {
                    drawMA(priceToY, timeToX, klineData, klineCtx, margin, chartWidth);
                }

                // 根据当前选中的图表类型绘制 K 线图
                if (currentChartType === 'candle') {
                    drawCandles(priceToY, timeToX, klineData, klineCtx, chartWidth);
                } else if (currentChartType === 'line') {
                    drawLineChart(priceToY, timeToX, klineData, klineCtx, chartWidth);
                } else if (currentChartType === 'area') {
                    drawAreaChart(priceToY, timeToX, klineData, klineCtx, minPrice, safePriceRange, chartWidth, margin);
                }
            }

            // 绘制成交量图
            function drawVolumeChart() {
                 if (klineData.length === 0 || !volumeCtx) return;

                // 计算最大成交量 (用于确定成交量 Y 轴的缩放比例)
                let maxVolume = 0;
                klineData.forEach(item => {
                    maxVolume = Math.max(maxVolume, item.volume);
                });

                 // 如果最大成交量为零，给一个默认值防止除以零
                 const safeMaxVolume = maxVolume > 0 ? maxVolume : 1;

                // 时间范围 (与 K 线图对齐)
                const startTime = klineData[0].time.getTime();
                const endTime = klineData[klineData.length - 1].time.getTime();
                 const timeRange = endTime - startTime;
                 const safeTimeRange = timeRange > 0 ? timeRange : 1; // 确保不会除以零

                // 将时间转换为 Canvas 上的 X 坐标 (与 K 线图对齐)
                function timeToX(time) {
                     const timeStamp = time.getTime();
                     const clampedTime = Math.max(startTime, Math.min(endTime, timeStamp));
                    // 注意：成交量图和 K 线图在同一个 chart-wrapper 内，水平对齐，所以 X 坐标转换逻辑可以共享
                     return margin.left + ((clampedTime - startTime) / safeTimeRange * chartWidth);
                }

                 // 将成交量转换为 Canvas 上的 Y 坐标
                 function volumeToY(volume) {
                     // 确保成交量在范围内
                     const clampedVolume = Math.max(0, Math.min(safeMaxVolume, volume));
                     // 注意：绘制成交量图时，Y 轴原点在顶部 (margin.top)，柱子向上长（Y 值减小）
                     return margin.top + volumeChartHeight - (clampedVolume / safeMaxVolume * volumeChartHeight);
                 }

                // 清除成交量画布内容，准备重新绘制
                volumeCtx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);


                // 绘制网格线和坐标轴标签 (成交量图只需要简单的水平线和垂直轴标签)
                 drawGridAndAxes(volumeCtx, 'volume', volumeToY, timeToX, safeMaxVolume, 0, startTime, endTime, chartWidth, volumeChartHeight, margin, currentTimeframe, true); // true 表示绘制成交量轴标签

                // 绘制成交量柱
                const barSpacing = chartWidth / klineData.length; // 每个数据点占用的水平空间
                const barWidth = Math.max(0.5, barSpacing * 0.8); // 确保柱子有最小宽度，柱子之间有留白
                const offset = barSpacing / 2; // 柱子中心相对于数据点起始位置的偏移量


                klineData.forEach((item, index) => {
                    // 计算柱子中心在 Canvas 上的 X 坐标
                    const x = margin.left + (index * barSpacing) + offset;
                    // 计算柱子左侧的 X 坐标
                    const barLeft = x - barWidth / 2;

                    // 计算柱子的高度
                    const barHeight = (item.volume / safeMaxVolume) * volumeChartHeight;
                    // 判断当前 K 线是涨是跌，决定柱子颜色
                    const isUp = item.close >= item.open;

                    // 设置柱子颜色
                    volumeCtx.fillStyle = isUp ? 'rgba(14, 203, 129, 0.6)' : 'rgba(246, 70, 93, 0.6)';
                    // 绘制柱子。注意：绘制柱状图是从底部开始绘制，所以 Y 坐标是 margin.top + volumeChartHeight - barHeight
                    volumeCtx.fillRect(barLeft, margin.top + volumeChartHeight - barHeight, barWidth, barHeight);
                });
            }

             // 绘制网格和坐标轴 (通用函数，用于 K 线图和成交量图)
             function drawGridAndAxes(ctx, type, yConverter, xConverter, maxY, minY, startTime, endTime, width, height, margin, interval, isVolume = false) {
                 ctx.strokeStyle = '#373c49'; // 网格线颜色
                 ctx.lineWidth = 1; // 网格线宽度

                 // 绘制图表区域的边框
                 ctx.strokeRect(margin.left, margin.top, width, height);

                 // 绘制水平网格线和价格/成交量标签
                 const ySteps = isVolume ? 2 : 5; // 成交量轴简单分段，K 线图分段更多
                 for (let i = 0; i <= ySteps; i++) {
                     // 计算当前网格线对应的数值 (价格或成交量)
                     const value = minY + ((maxY - minY) * i / ySteps);
                     // 将数值转换为 Canvas 上的 Y 坐标
                     const y = yConverter(value);

                     // 绘制网格线 (避开边框线)
                     // K 线图不绘制最顶部和最底部的水平网格线，成交量图绘制中间线
                     if ((i > 0 && i < ySteps) || isVolume) {
                         ctx.beginPath();
                         ctx.setLineDash([2, 2]); // 设置虚线样式
                         ctx.moveTo(margin.left, y); // 从左边框开始
                         ctx.lineTo(margin.left + width, y); // 画到右边框
                         ctx.stroke(); // 绘制线条
                         ctx.setLineDash([]); // 恢复实线样式
                     }


                     // 绘制价格/成交量标签 (只在左侧绘制)
                     ctx.fillStyle = '#848e9c'; // 标签文本颜色
                     ctx.font = '10px Arial'; // 标签字体
                     ctx.textAlign = 'right'; // 文本右对齐
                     ctx.textBaseline = 'middle'; // 文本垂直居中对齐到 Y 坐标
                     // 格式化标签文本
                     let labelText = isVolume ? formatVolume(value) : value.toFixed(maxY > 1000 ? 0 : 2); // 根据价格大小调整小数位数
                      if (value === 0 && isVolume) labelText = '0'; // 确保成交量轴底部的0显示

                     // 绘制标签文本，位置在左边框左侧一点
                     ctx.fillText(labelText, margin.left - 5, y);
                 }

                 // 绘制垂直网格线和时间标签 (只在 K 线图绘制)
                 if (!isVolume) {
                     const timeRange = endTime - startTime;
                     const timeSteps = Math.min(10, klineData.length); // 最多显示 10 个时间标签
                      // 根据时间间隔和数据点数量调整显示的标签数量，避免拥挤
                     let step = 1;
                      if (klineData.length > 100 && (interval === '1m' || interval === '5m')) {
                          step = 10; // 数据点多时，跳过一些标签
                      } else if (klineData.length > 200 && (interval === '15m' || interval === '1h')) {
                           step = 20;
                      } else if (klineData.length > 100 && interval === '4h') { // 4小时图数据点较多时
                          step = 10;
                      }

                      // 确定需要绘制标签的数据点索引
                      const indicesToDraw = [];
                      for (let i = 0; i < klineData.length; i+= step) {
                          indicesToDraw.push(i);
                      }
                      // 如果最后一个数据点没有被包含，则添加，确保图表右侧有时间标签
                      if (klineData.length > 0 && !indicesToDraw.includes(klineData.length - 1)) {
                          indicesToDraw.push(klineData.length - 1);
                      }


                     if (timeSteps > 0) {
                          indicesToDraw.forEach(i => {
                              const time = klineData[i].time;
                              // 将时间转换为 Canvas 上的 X 坐标
                              const x = xConverter(time);

                              // 绘制网格线 (避开边框线)
                               // 不绘制最左侧和最右侧的垂直网格线
                               if (i > 0 && i < klineData.length - 1) {
                                  ctx.beginPath();
                                  ctx.setLineDash([2, 2]); // 设置虚线样式
                                  ctx.moveTo(x, margin.top); // 从上边框开始
                                  ctx.lineTo(x, margin.top + height); // 画到下边框
                                  ctx.stroke(); // 绘制线条
                                  ctx.setLineDash([]); // 恢复实线样式
                              }


                              // 绘制时间标签 (只在底部绘制)
                              ctx.fillStyle = '#848e9c'; // 标签文本颜色
                              ctx.font = '10px Arial'; // 标签字体
                              ctx.textAlign = 'center'; // 文本居中对齐
                              ctx.textBaseline = 'top'; // 文本顶部对齐到 Y 坐标
                              let timeStr;

                              // 根据时间间隔格式化时间字符串
                              if (interval === '1d') {
                                  timeStr = time.toLocaleDateString([], { month: 'short', day: 'numeric' }); // 日期格式
                              } else if (interval === '4h') {
                                  timeStr = `${time.getMonth() + 1}/${time.getDate()} ${time.getHours()}:00`; // 月/日 时:00 格式
                              }
                              else {
                                  timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); // 时:分 格式
                              }

                              // 确保时间标签不会超出左右边界
                              const textWidth = ctx.measureText(timeStr).width; // 测量文本宽度
                              // 计算标签绘制的 X 坐标，确保居中且不越界
                              const labelX = Math.max(margin.left, Math.min(margin.left + width - textWidth/2, x - textWidth/2));

                              // 绘制标签文本，位置在下边框下方一点
                              ctx.fillText(timeStr, labelX + textWidth/2, margin.top + height + 5);
                          });
                     }
                 }
             }


            // 绘制蜡烛图
            function drawCandles(priceToY, timeToX, data, ctx, chartWidth) {
                 // 根据数据点数量动态计算蜡烛宽度和间隔
                 const barSpacing = chartWidth / data.length; // 每个数据点占用的水平空间
                 const candleWidth = Math.max(0.5, barSpacing * 0.8); // 蜡烛实体宽度，留白 20%，确保最小宽度
                 const offset = barSpacing / 2; // 蜡烛中心相对于数据点起始位置的偏移量


                data.forEach((item, index) => {
                    // 计算蜡烛中心在 Canvas 上的 X 坐标
                    const x = margin.left + (index * barSpacing) + offset;
                    // 将开盘价、收盘价、最高价、最低价转换为 Canvas 上的 Y 坐标
                    const openY = priceToY(item.open);
                    const closeY = priceToY(item.close);
                    const highY = priceToY(item.high);
                    const lowY = priceToY(item.low);

                    // 确定蜡烛的涨跌颜色
                    const isUp = item.close >= item.open;
                    ctx.fillStyle = isUp ? '#0ecb81' : '#f6465d'; // 实体填充颜色
                    ctx.strokeStyle = isUp ? '#0ecb81' : '#f6465d'; // 影线和边框颜色
                     ctx.lineWidth = 1; // 边框和影线宽度

                    // 绘制影线 (从最高点到最低点)
                    ctx.beginPath();
                    ctx.moveTo(x, highY);
                    ctx.lineTo(x, lowY);
                    ctx.stroke();

                    // 绘制蜡烛实体
                    const candleHeight = Math.abs(openY - closeY); // 实体高度
                    const candleY = Math.min(openY, closeY); // 实体顶部的 Y 坐标

                    // 如果开盘价等于收盘价或非常接近，绘制一条横线表示“一字线”
                     if (candleHeight < 1 / (window.devicePixelRatio || 1)) { // 小于1像素高度的视为一条线，考虑 DPR
                         ctx.beginPath();
                         ctx.moveTo(x - candleWidth / 2, openY);
                         ctx.lineTo(x + candleWidth / 2, openY);
                         ctx.stroke();
                     } else {
                        // 绘制实体矩形
                        ctx.fillRect(x - candleWidth / 2, candleY, candleWidth, candleHeight);
                        // 绘制蜡烛边框 (可选，与实体颜色相同)
                        // ctx.strokeRect(x - candleWidth / 2, candleY, candleWidth, candleHeight);
                     }
                });
            }

            // 绘制折线图 (使用收盘价连接形成的折线)
            function drawLineChart(priceToY, timeToX, data, ctx, chartWidth) {
                ctx.strokeStyle = '#f0b90b'; // 折线颜色
                ctx.lineWidth = 2; // 折线宽度
                ctx.beginPath(); // 开始绘制路径

                 // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length; // 每个数据点占用的水平空间
                 const offset = barSpacing / 2; // 点中心相对于数据点起始位置的偏移量


                data.forEach((item, index) => {
                    // 计算数据点中心在 Canvas 上的 X 坐标
                    const x = margin.left + (index * barSpacing) + offset;
                    // 将收盘价转换为 Canvas 上的 Y 坐标
                    const y = priceToY(item.close);

                    // 如果是第一个点，移动到该点；否则，连接到该点
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke(); // 绘制路径
            }

            // 绘制面积图 (收盘价折线与图表底部形成的区域)
            function drawAreaChart(priceToY, timeToX, data, ctx, minPrice, priceRange, chartWidth, margin) {
                ctx.fillStyle = 'rgba(240, 185, 11, 0.2)'; // 填充颜色 (半透明黄色)
                ctx.strokeStyle = '#f0b90b'; // 边框颜色 (黄色)
                ctx.lineWidth = 2; // 边框宽度
                ctx.beginPath(); // 开始绘制路径

                // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length; // 每个数据点占用的水平空间
                 const offset = barSpacing / 2; // 点中心相对于数据点起始位置的偏移量


                // 绘制上边线 (收盘价折线)
                data.forEach((item, index) => {
                     // 计算数据点中心在 Canvas 上的 X 坐标
                     const x = margin.left + (index * barSpacing) + offset;
                    // 将收盘价转换为 Canvas 上的 Y 坐标
                    const y = priceToY(item.close);

                    // 如果是第一个点，移动到该点；否则，连接到该点
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                // 绘制下边线形成闭合区域 (连接到图表底部中心)
                 // 面积图底部延伸到图表底部 (考虑 margin)
                 const baseY = margin.top + chartHeight;

                 // 计算最后一个数据点和第一个数据点的 X 坐标
                 const lastX = margin.left + (data.length - 1) * barSpacing + offset;
                 const firstX = margin.left + (0 * barSpacing) + offset;

                // 从最后一个数据点连接到图表右下角
                ctx.lineTo(lastX, baseY);
                // 从图表右下角连接到图表左下角
                ctx.lineTo(firstX, baseY);
                // 从图表左下角连接回第一个数据点 (闭合路径)
                ctx.closePath();

                ctx.fill(); // 填充区域
                ctx.stroke(); // 绘制边框
            }

            // 绘制移动平均线 (MA)
            function drawMA(priceToY, timeToX, data, ctx, margin, chartWidth) {
                // MA 线的颜色，对应 MA5, MA10, MA20
                const maColors = ['#9b59b6', '#3498db', '#e74c3c'];
                const periods = [5, 10, 20]; // MA 计算周期

                 // 根据数据点数量计算间隔
                 const barSpacing = chartWidth / data.length; // 每个数据点占用的水平空间
                 const offset = barSpacing / 2; // 点中心相对于数据点起始位置的偏移量


                periods.forEach((period, idx) => {
                    // 只有当 MA 指标被激活且数据长度足够计算当前周期的 MA 时才绘制
                    if (!activeIndicators.includes('ma') || data.length < period) return;

                    ctx.strokeStyle = maColors[idx % maColors.length]; // 设置线条颜色，循环使用
                    ctx.lineWidth = 1; // 线条宽度
                    ctx.beginPath(); // 开始绘制路径

                    // 从第一个可以计算 MA 的数据点开始绘制
                    for (let i = period - 1; i < data.length; i++) {
                        // 计算数据点中心在 Canvas 上的 X 坐标
                        const x = margin.left + (i * barSpacing) + offset;
                        // 将计算好的 MA 值转换为 Canvas 上的 Y 坐标
                        const y = priceToY(data[i][`ma${period}`]);

                        // 如果是 MA 线的第一个点，移动到该点；否则，连接到该点
                        if (i === period - 1) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke(); // 绘制路径

                    // 在图表右上角添加 MA 图例/标签
                     const lastItem = data[data.length - 1];
                     // 确保最后一个数据点存在计算出的 MA 值
                     if (lastItem && lastItem[`ma${period}`] !== undefined && !isNaN(lastItem[`ma${period}`])) {
                         // 构建标签文本
                         const labelText = `MA${period}: ${lastItem[`ma${period}`].toFixed(2)}`;
                         // 计算标签绘制的 X, Y 坐标，使其位于图表右上角区域
                         // 根据标签数量调整起始位置和间隔，避免重叠
                         const labelX = margin.left + chartWidth - 180 + idx * 60; // 右侧区域，调整起始位置和间隔
                         const labelY = margin.top + 15 + idx * 15; // 顶部区域，调整起始位置和间隔

                         ctx.fillStyle = maColors[idx % maColors.length]; // 使用与 MA 线相同的颜色
                         ctx.font = '10px Arial'; // 字体
                         ctx.textAlign = 'left'; // 文本左对齐
                          ctx.textBaseline = 'top'; // 文本顶部对齐到 Y 坐标
                         ctx.fillText(labelText, labelX, labelY); // 绘制文本
                     }
                });
            }

            // 格式化成交量数值，使其更易读 (例如 1.2M, 500K)
            function formatVolume(volume) {
                if (volume === undefined || volume === null || isNaN(volume)) return '--'; // 检查是否为有效数字
                if (volume >= 1000000000) {
                    return (volume / 1000000000).toFixed(1) + 'B'; // 十亿以上显示 B
                } else if (volume >= 1000000) {
                    return (volume / 1000000).toFixed(1) + 'M'; // 百万以上显示 M
                } else if (volume >= 1000) {
                    return (volume / 1000).toFixed(1) + 'K'; // 千以上显示 K
                }
                return volume.toFixed(0); // 小于千显示整数
            }

            // 设置十字线交互 (鼠标移动和移出事件)
            function setupCrosshair() {
                // 鼠标移动事件监听 (监听 K 线图 Canvas)
                klineCanvas.addEventListener('mousemove', (e) => {
                    // 确保 Canvas 上下文和数据都有效
                    if (!klineCtx || !crosshairCtx || klineData.length === 0) {
                         crosshairInfo.style.display = 'none'; // 隐藏信息框
                         // 清除成交量图上的垂直线 (如果在 mousemove 中绘制了)
                         if (volumeCtx && klineData.length > 0) {
                             drawVolumeChart(); // 重新绘制成交量图，清除垂直线
                         }
                         return; // 不满足条件则退出
                    }

                    // 清除之前的十字线 (只清除 overlay Canvas 上的十字线)
                    crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height);
                    // 不在 mousemove 中清除成交量图的垂直线，改为在 mouseout 时清除，避免闪烁

                    // 获取 Canvas 在视口中的位置和尺寸
                    const rect = klineCanvas.getBoundingClientRect();
                    // 计算鼠标相对于 K 线图 Canvas 左上角的坐标
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // 检查鼠标是否在 K 线图的绘制区域内 (考虑边距)
                    if (x < margin.left || x > margin.left + chartWidth ||
                        y < margin.top || y > margin.top + chartHeight) {
                        crosshairInfo.style.display = 'none'; // 鼠标移出图表区域，隐藏信息框
                        // 清除成交量图上的垂直线 (如果在 mousemove 中绘制了)
                        if (volumeCtx && klineData.length > 0) {
                             drawVolumeChart(); // 重新绘制成交量图，清除垂直线
                         }
                        return; // 鼠标移出图表区域，不绘制十字线
                    }

                    // ----- 查找最接近鼠标位置的数据点 -----

                    let closestItem = null;
                    let minDiff = Infinity; // 最小距离
                    let closestIndex = -1; // 最接近数据点的索引

                    const barSpacing = chartWidth / klineData.length; // 计算每个数据点在 Canvas 上占用的水平空间

                    klineData.forEach((item, index) => {
                        // 计算当前数据点中心在 Canvas 上的 X 坐标
                        const itemCenterX = margin.left + (index * barSpacing) + barSpacing / 2;
                        // 计算鼠标 X 坐标与数据点中心 X 坐标的距离
                        const diff = Math.abs(x - itemCenterX);

                        // 找到距离最小的数据点
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestItem = item;
                            closestIndex = index;
                        }
                    });

                    // ----- 绘制十字线和信息框 -----

                    if (closestItem) {
                         // 使用找到的最接近数据点中心在 Canvas 上的精确 X 坐标来绘制垂直线
                         const crosshairX = margin.left + (closestIndex * barSpacing) + barSpacing / 2;


                        // 绘制十字线 (在 overlay Canvas 上绘制水平线和垂直线)
                        // 水平线 Y 坐标使用鼠标当前的 Y 坐标
                        drawCrosshair(crosshairCtx, crosshairX, y, margin, chartWidth, crosshairOverlayHeight, closestItem.close.toFixed(2), closestItem.time, currentTimeframe, false); // K线图十字线

                        // 在成交量图上绘制对应的垂直线 (使用 volumeCtx 绘制)
                        // 先清除成交量图并重绘，然后在其上面绘制垂直线，确保垂直线不会残留
                        drawVolumeChart(); // 重新绘制成交量图，清除旧的垂直线
                        // crosshairX 是相对于 chart-wrapper 的 X 坐标，直接使用即可
                         drawCrosshair(volumeCtx, crosshairX, margin.top + volumeChartHeight / 2, margin, chartWidth, volumeChartHeight, null, null, null, true); // 成交量图垂直线


                        // 显示并定位信息框
                        crosshairInfo.style.display = 'block';
                        // 定位信息框，使其跟随鼠标，并避免超出屏幕边界
                        const infoBoxWidth = crosshairInfo.offsetWidth;
                        const infoBoxHeight = crosshairInfo.offsetHeight;
                        let infoX = e.clientX + 15; // 初始位置在鼠标右侧偏移 15px
                        let infoY = e.clientY + 15; // 初始位置在鼠标下方偏移 15px

                        // 调整位置以防超出右边界
                        if (infoX + infoBoxWidth > window.innerWidth - 20) { // 留一些边距
                            infoX = e.clientX - infoBoxWidth - 15; // 改到鼠标左侧偏移
                        }
                         // 调整位置以防超出下边界
                         if (infoY + infoBoxHeight > window.innerHeight - 20) { // 留一些边距
                             infoY = e.clientY - infoBoxHeight - 15; // 改到鼠标上方偏移
                         }
                         // 调整位置以防超出左边界
                         if (infoX < 10) infoX = 10; // 最小左边距
                         // 调整位置以防超出上边界
                         if (infoY < 10) infoY = 10; // 最小上边距


                        crosshairInfo.style.left = `${infoX}px`; // 设置信息框的 left 属性
                        crosshairInfo.style.top = `${infoY}px`; // 设置信息框的 top 属性

                        // 构建信息框内容 (显示当前数据点的详细信息)
                        let infoContent = `
                            <div><span>时间:</span> ${closestItem.time.toLocaleString()}</div>
                            <div><span>开盘:</span> ${closestItem.open.toFixed(2)}</div>
                            <div><span>最高:</span> ${closestItem.high.toFixed(2)}</div>
                            <div><span>最低:</span> ${closestItem.low.toFixed(2)}</div>
                            <div><span>收盘:</span> ${closestItem.close.toFixed(2)}</div>
                            <div><span>成交量:</span> ${formatVolume(closestItem.volume)}</div>
                        `;

                         // 如果有激活的 MA 指标，添加到信息框中
                         const periods = [5, 10, 20];
                         if (activeIndicators.includes('ma')) {
                             periods.forEach(period => {
                                 // 确保该数据点有计算出的 MA 值且是有效数字
                                 if (closestItem[`ma${period}`] !== undefined && !isNaN(closestItem[`ma${period}`])) {
                                     infoContent += `<div><span>MA${period}:</span> ${closestItem[`ma${period}`].toFixed(2)}</div>`;
                                 }
                             });
                         }
                        // TODO: 添加其他激活指标的信息显示

                        crosshairInfo.innerHTML = infoContent; // 更新信息框内容

                    } else {
                        crosshairInfo.style.display = 'none'; // 没有找到最近数据点，隐藏信息框
                         // 清除成交量图上的垂直线
                         if (volumeCtx && klineData.length > 0) {
                             drawVolumeChart();
                         }
                    }
                });

                // 鼠标移出事件监听 (监听 K 线图 Canvas)
                klineCanvas.addEventListener('mouseout', () => {
                    // 清除十字线 overlay Canvas 内容和信息框
                    if (crosshairCtx) {
                         crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height);
                    }
                    crosshairInfo.style.display = 'none'; // 隐藏信息框
                     // 鼠标移出时，也清除成交量图上的垂直线
                     if (volumeCtx && klineData.length > 0) {
                         // 重新绘制成交量图，清除十字线垂直线
                         drawVolumeChart(); // 这是为了清除成交量图上的垂直线
                     }
                });

                 // 防止在 Canvas 上右键弹出浏览器默认菜单
                 klineCanvas.addEventListener('contextmenu', (e) => {
                     e.preventDefault();
                 });

                 // 当窗口大小变化时，隐藏十字线和信息框，并重新初始化 Canvas
                 window.addEventListener('resize', () => {
                     crosshairInfo.style.display = 'none'; // 隐藏信息框
                     if (crosshairCtx) {
                          crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height); // 清除十字线 overlay
                     }
                     // 重新绘制成交量图以清除可能的垂直线
                     if (volumeCtx && klineData.length > 0) {
                          drawVolumeChart();
                     }
                     // 窗口大小变化后重新初始化 Canvas 尺寸并重绘图表
                     initCanvas();
                     // 重新绘制当前缓存的数据 (或者重新获取数据，取决于需求)
                     if (klineDataCache.has(currentTimeframe)) {
                         klineData = klineDataCache.get(currentTimeframe);
                         calculateIndicators(); // 重新计算指标以适应新尺寸（如果指标计算依赖尺寸）
                         drawCharts();
                     } else {
                         // 如果当前周期数据不在缓存（不应该发生，除非刚加载），重新获取
                          getKlineData(currentTimeframe);
                     }
                 });
            }

             // 绘制十字线 (在 overlay Canvas 或 volume Canvas 上绘制)
             // ctx: 绘制上下文, x, y: 十字线中心坐标, margin: 边距, width, height: 绘制区域尺寸
             // priceText: 价格标签文本 (K线图), timeObj: 时间对象 (K线图), interval: 时间间隔 (K线图)
             // isVolume: 是否在成交量图上绘制
             function drawCrosshair(ctx, x, y, margin, width, height, priceText, timeObj, interval, isVolume = false) {
                 // 保存当前 Canvas 状态
                 ctx.save();

                 ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // 十字线颜色 (半透明白色)
                 ctx.setLineDash([2, 2]); // 设置虚线样式
                 ctx.lineWidth = 1; // 线条宽度

                 // 绘制水平线 (如果在 K 线图且在绘制区域内)
                 if (!isVolume && y >= margin.top && y <= margin.top + height) {
                     ctx.beginPath(); // 开始绘制路径
                     ctx.moveTo(margin.left, y); // 从左边框开始
                     ctx.lineTo(margin.left + width, y); // 画到右边框
                     ctx.stroke(); // 绘制线条

                     // 绘制价格标签背景和文本 (只在 K线图绘制)
                     if (priceText !== null) {
                        ctx.fillStyle = '#f0b90b'; // 背景颜色
                        ctx.font = '10px Arial'; // 字体
                        const priceLabelWidth = ctx.measureText(priceText).width + 10; // 根据文本宽度调整背景宽度，留白 10px
                        // 绘制背景矩形，位置在右边框右侧一点
                        ctx.fillRect(margin.left + width, y - 8, priceLabelWidth, 16); // 高度固定 16px

                        // 绘制价格标签文本
                        ctx.fillStyle = '#1e222d'; // 文本颜色
                        ctx.textAlign = 'left'; // 文本左对齐
                        ctx.textBaseline = 'middle'; // 文本垂直居中对齐到 Y 坐标
                        ctx.fillText(priceText, margin.left + width + 5, y); // 绘制文本，位置在背景右侧偏移 5px
                     }
                 }


                 // 绘制垂直线 (如果在图表绘制区域内)
                 if (x >= margin.left && x <= margin.left + width) {
                     ctx.beginPath(); // 开始绘制路径
                     // 垂直线从图表区域的顶部到底部绘制
                     // 如果是成交量图，垂直线从 volumeCanvas 的 margin.top 开始到 margin.top + volumeChartHeight 结束
                     // 如果是 K 线图 (overlay)，垂直线从 overlay Canvas 的 0 开始到 height 结束
                     ctx.moveTo(x, isVolume ? margin.top : 0);
                     ctx.lineTo(x, isVolume ? margin.top + height : height);
                     ctx.stroke(); // 绘制线条

                      // 绘制时间标签背景和文本 (只在 K 线图底部绘制)
                     if (!isVolume && timeObj) {
                         // 格式化时间字符串
                         let timeStr;
                         if (interval === '1d') {
                             timeStr = timeObj.toLocaleDateString([], { month: 'short', day: 'numeric' });
                         } else if (interval === '4h') {
                              timeStr = `${timeObj.getMonth() + 1}/${timeObj.getDate()} ${timeObj.getHours()}:00`;
                         }
                         else {
                              timeStr = timeObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                         }

                         ctx.font = '10px Arial'; // 再次设置字体，确保measureText准确
                         const textWidth = ctx.measureText(timeStr).width; // 测量文本宽度
                         ctx.fillStyle = '#f0b90b'; // 背景颜色
                         // 确保时间标签不会超出左右边界，并使其居中对齐到垂直线上
                         const labelX = Math.max(margin.left, Math.min(margin.left + width - (textWidth + 10)/2, x - (textWidth + 10)/2)); // 修正：考虑背景宽度


                         // 绘制背景矩形，位置在下边框下方一点
                         ctx.fillRect(labelX, margin.top + height, textWidth + 10, 20); // 宽度根据文本调整，高度固定 20px

                         // 绘制时间标签文本
                         ctx.fillStyle = '#1e222d'; // 文本颜色
                         ctx.textAlign = 'center'; // 文本居中对齐
                         ctx.textBaseline = 'middle'; // 文本垂直居中对齐到背景框
                          ctx.fillText(timeStr, labelX + (textWidth + 10)/2, margin.top + height + 10); // 修正：居中文本
                     }
                 }

                 // 恢复之前保存的 Canvas 状态
                 ctx.restore();
             }


            // 自动刷新函数，定时获取最新价格和 K 线数据
            function startAutoRefresh(interval = 5000) { // 默认刷新间隔 5 秒
                // 清除现有定时器，避免重复启动
                if (refreshInterval) {
                    clearInterval(refreshInterval);
                }

                // 立即获取一次数据并启动定时器
                getBinanceBTCPrice(); // 获取实时价格
                // 首次加载或切换周期时，总是获取当前时间周期的 K 线数据（可能从缓存或 API）
                getKlineData(currentTimeframe);

                // 启动定时器，每隔指定间隔执行一次
                refreshInterval = setInterval(async () => {
                    // 在定时器中先获取最新价格
                    await getBinanceBTCPrice();
                    // 定时刷新时，重新获取当前时间周期的最新数据并更新图表
                    // 这会获取 limit 数量的最新数据，并重新绘制整个图表
                    getKlineData(currentTimeframe);
                }, interval); // 设置刷新间隔

                console.log(`开始自动刷新，间隔: ${interval}ms`);
            }

            // 窗口大小变化事件监听，用于重新初始化 Canvas 尺寸和重绘图表
            window.addEventListener('resize', () => {
                console.log("窗口大小变化，重新初始化Canvas...");
                 // 重新初始化 Canvas 尺寸
                 initCanvas();
                 // 重新绘制当前缓存的数据 (或者重新获取数据，取决于需求)
                 if (klineDataCache.has(currentTimeframe)) {
                     klineData = klineDataCache.get(currentTimeframe);
                     calculateIndicators(); // 重新计算指标以适应新尺寸（如果指标计算依赖尺寸）
                     drawCharts(); // 重新绘制图表
                 } else {
                     // 如果当前周期数据不在缓存（不应该发生，除非刚加载），重新获取
                      getKlineData(currentTimeframe);
                 }
                 // 窗口大小变化时，隐藏十字线和信息框
                 crosshairInfo.style.display = 'none';
                 if (crosshairCtx) {
                      crosshairCtx.clearRect(0, 0, crosshairOverlay.width, crosshairOverlay.height);
                 }
                 if (volumeCtx && klineData.length > 0) {
                      drawVolumeChart(); // 清除成交量图上的垂直线
                 }
            });


            // 页面加载完成后的初始化流程
            // 确保 DOM 元素都已加载
            document.addEventListener('DOMContentLoaded', () => {
                 initCanvas(); // 首次初始化 Canvas
                 setupCrosshair(); // 设置十字线交互
                 startAutoRefresh(); // 开始自动刷新

                 // 激活默认选中的时间周期和图表类型按钮
                 document.querySelector('.timeframe-tab.active').classList.add('active');
                 document.querySelector('.toolbar-btn[data-type].active').classList.add('active');
                 // 激活默认选中的指标按钮
                 activeIndicators.forEach(indicator => {
                     const btn = document.querySelector(`.toolbar-btn[data-indicator="${indicator}"]`);
                     if (btn) btn.classList.add('active');
                 });
            });


            // 时间周期切换事件监听
            timeframeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // 如果点击的是当前已激活的标签，则不执行任何操作
                    if (tab.classList.contains('active')) return;

                    // 移除所有时间周期标签的 active 类
                    timeframeTabs.forEach(t => t.classList.remove('active'));
                    // 给当前点击的标签添加 active 类
                    tab.classList.add('active');
                    // 更新当前选中的时间周期
                    currentTimeframe = tab.dataset.interval;
                    console.log(`切换时间周期到: ${currentTimeframe}`);
                    // 切换时间周期时，清除当前的自动刷新定时器
                    clearInterval(refreshInterval);
                    refreshInterval = null; // 清除引用
                    // 获取新时间周期的 K 线数据（可能从缓存或 API）
                    getKlineData(currentTimeframe);
                    // 重新开始自动刷新（新的定时器会获取当前周期的数据）
                    startAutoRefresh();
                });
            });

            // 图表类型切换事件监听
            chartTypeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    // 如果点击的是当前已激活的按钮，则不执行任何操作
                    if (btn.classList.contains('active')) return;

                    // 移除所有图表类型按钮的 active 类
                    chartTypeBtns.forEach(b => b.classList.remove('active'));
                    // 给当前点击的按钮添加 active 类
                    btn.classList.add('active');
                    // 更新当前选中的图表类型
                    currentChartType = btn.dataset.type;
                    console.log(`切换图表类型到: ${currentChartType}`);
                     // 切换图表类型只需根据当前数据重新绘制，不需要重新获取数据或计算指标
                    drawCharts();
                });
            });

            // 技术指标切换事件监听
            indicatorBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const indicator = btn.dataset.indicator; // 获取点击的指标类型
                    const index = activeIndicators.indexOf(indicator); // 查找指标是否已激活

                    if (index === -1) { // 如果指标未激活
                        // 检查是否是已实现的指标 (目前只处理 MA)
                        if (indicator === 'ma') {
                             activeIndicators.push(indicator); // 添加到激活指标列表
                             btn.classList.add('active'); // 添加 active 类
                             console.log(`添加技术指标: ${indicator}`);
                        } else {
                            console.warn(`技术指标 ${indicator} 尚未实现。`);
                            // 可以给用户一个提示，例如弹窗或在页面上显示信息
                            // alert(`技术指标 ${indicator} 尚未实现。`);
                            return; // 未实现的指标不添加，并退出
                        }

                    } else { // 如果指标已激活
                        activeIndicators.splice(index, 1); // 从激活指标列表中移除
                        btn.classList.remove('active'); // 移除 active 类
                        console.log(`移除技术指标: ${indicator}`);
                    }

                    calculateIndicators(); // 重新计算所有激活的指标 (基于当前的 klineData)
                    drawCharts(); // 重新绘制图表以显示/隐藏指标线
                });
            });

            // 页面可见性变化事件监听，用于在页面隐藏时停止刷新，页面可见时恢复刷新
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // 页面不可见时清除定时器
                    if (refreshInterval) {
                       clearInterval(refreshInterval);
                       refreshInterval = null; // 清除引用
                       console.log("页面隐藏，停止自动刷新。");
                    }
                } else {
                    // 页面可见时重新开始定时刷新
                    if (!refreshInterval) { // 确保没有重复启动定时器
                        startAutoRefresh();
                        console.log("页面可见，恢复自动刷新。");
                    }
                }
            });

            // 初始加载时，如果数据加载失败，提供刷新按钮（可选）
            // loadingOverlay.addEventListener('click', () => {
            //      if (loadingOverlay.querySelector('div').textContent.includes('失败')) {
            //          window.location.reload(); // 点击失败提示时刷新页面
            //      }
            // });

        })(); // IIFE 结束
    </script>
</body>
</html>
